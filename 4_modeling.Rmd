---
title: "Analyse terrestrial indicators"
author: "Simone Stevenson"
date: "20/09/2021"
output:
  html_document: default
  pdf_document: default
---


```{r setup, include=FALSE}

# https://bookdown.org/yihui/rmarkdown/r-code.html

knitr::opts_chunk$set(echo = FALSE, message = FALSE,
  warnings = FALSE, error = FALSE)

```

Directory path to git repo

Simone's deakin laptop

cd "C:\\Users\\ssteven\\OneDrive - Deakin University\\Deakin\\Chapter_3_indicator_testing\\madingley_terrestrial_indicators"

Data structure

Input data is structured hierarchically as follows:
- Location (1)
-- Scenarios (3)
--- Replicates (25)

Output indicator data is calculated at the same level, so each indicator should
have values for:
- Location (1)
-- Scenarios (3)
--- Replicates (25)

# Possible useful ref?
https://www.frontiersin.org/articles/10.3389/fevo.2018.00149/full

```{r libraries}

## Data wrangling
library(tidyverse)
library(zoo)

## Analysis
library(mgcv)
library(nlme)
library(MASS)
library(datawizard)

## Viz
library(ggpubr)
library(cowplot)
library(gridExtra)
library(gratia)
library(kableExtra)
library(viridis)
library(viridisLite)

```

```{r template chunk}

```

```{r ggplot theme}

plot_theme <- theme(panel.background = element_blank(),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              legend.position = "bottom",
              legend.key.size = unit(0.25, 'cm'),
              plot.title = element_text(size = 10, face = "bold"),
              legend.title=element_text(size=6), 
              legend.text=element_text(size=5),
              axis.line = element_line(colour = "black"),
              axis.title.x = element_text(size=8),
              axis.title.y = element_text(size=8),
              axis.text.x = element_text(size=8),
              axis.text.y = element_text(size=8),
              axis.ticks.x = element_blank(), 
              axis.ticks.y = element_blank())

```

```{r colour palettes, eval=FALSE}

library(scales)
show_col(viridis_pal()(20))
show_col(viridis_pal(option = "plasma")(20))
show_col(viridis_pal(option = "magma")(20))
show_col(viridis_pal(option = "inferno")(20))
show_col(viridis_pal(option = "mako")(20))
show_col(viridis_pal(option = "cividis")(20))
show_col(viridis_pal(option = "rocket")(20))
show_col(viridis_pal(option = "turbo")(20))


```

```{r get species gam data }

#' @param model - gam object
#' @param data - the input pressure response time step data for the model
#' @return a dataframe containing predicted, observed, first and second derivatives

get_species_gam_data <- function(data, model, scenario) {
  
# Get observed indicator values

observed <- data$std_abundance

# Make a dataframe of predictor vals (ie timesteps)

pdat1 <- data.frame(annual_time_step = seq(1,nrow(data),1))

# Get predicted values for each time step
# p2 <- predict.gam(model, pdat1, 
#                   se.fit = TRUE, response = TRUE)

p2 <- predict(model, pdat1, 
                  se.fit = TRUE, response = TRUE)

p3 <- predict.gam(model, pdat1, 
                  se.fit = TRUE)

# # Get the deviance residuals
deviance_residuals <- residuals(model, type = "working")

# fv <- predict(model,type="terms") ## get term estimates
#      
# ## compute partial residuals for first smooth...          
# deviance_residuals <- residuals(model,type="working", response = TRUE) + fv[,1]

#Bind them together with observed vals

pdat <- cbind(pdat1, predicted = p2$fit, predicted_nr = p3$fit, se2 = p2$se.fit, observed, 
              deviance_residuals)

#Get upper and lower bounds for predicted values (replace with bootstraps for selected model)

df.res <- df.residual(model)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
pdat <- transform(pdat,
                  upper_pred = predicted_nr + (crit.t * se2),
                  lower_pred = predicted_nr - (crit.t * se2))

# Calculate the derivatives and add that too
derivs_1 <- as.data.frame(derivatives(model, order = 1, 
                   n = nrow(data), interval = "confidence") ) %>% 
                   dplyr::select(derivative, lower, upper) %>% 
                   rename(first_derivative = derivative,
                          first_lower = lower,
                          first_upper = upper)

# Calculate the derivatives and add that too
derivs_2 <- as.data.frame(derivatives(model, order = 2, 
                   n = nrow(data), interval = "confidence") ) %>% 
                   dplyr::select(derivative, lower, upper) %>% 
                   rename(second_derivative = derivative,
                          second_lower = lower,
                          second_upper = upper)
# Bind it all together
temp <- cbind(pdat, derivs_1, derivs_2)


# Make the final plot data
test_gam_data <- temp %>% 
                 mutate(first_significant = ifelse(first_lower <= 0 & 
                                                  first_upper >= 0, FALSE, TRUE),
                        positive_trend = ifelse(first_significant == TRUE & 
                                                 first_derivative > 0,
                                            predicted_nr,NA),
                        negative_trend = ifelse(first_significant == TRUE & 
                                                 first_derivative < 0,
                                            predicted_nr, NA),
                        positive_der_1 = ifelse(first_significant == TRUE & 
                                                  first_derivative > 0,
                                            first_derivative,NA),
                        negative_der_1 = ifelse(first_significant == TRUE & 
                                                  first_derivative < 0,
                                            first_derivative, NA),
                        second_significant = ifelse(second_lower <= 0 & 
                                                  first_upper >= 0, FALSE, TRUE),
                        positive_tp = ifelse(second_significant == TRUE & 
                                             second_derivative > 0,
                                            predicted_nr,NA),
                        negative_tp = ifelse(second_significant == TRUE & 
                                            second_derivative < 0,
                                            predicted_nr, NA),
                        positive_der_2 = ifelse(second_significant == TRUE & 
                                                second_derivative > 0,
                                            second_derivative,NA),
                        negative_der_2 = ifelse(second_significant == TRUE & 
                                                second_derivative < 0,
                                            first_derivative, NA),
                        indicator = data$group_id[1],
                        scenario = scenario,
                        kvalue = model$rank,
                        r2 = summary.gam(model)$r.sq) 

}
```

```{r get test gam data }

#' @param model - gam object
#' @param data - the input pressure response time step data for the model
#' @return a dataframe containing predicted, observed, first and second derivatives

get_test_gam_data <- function(data, model, scenario) {
  
# Get observed indicator values

observed <- data$indicator_score

# Make a dataframe of predictor vals (ie timesteps)

pdat1 <- data.frame(annual_time_step = seq(1,nrow(data),1))

# Get predicted values for each time step
# p2 <- predict.gam(model, pdat1, 
#                   se.fit = TRUE, response = TRUE)

p2 <- predict(model, pdat1, 
                  se.fit = TRUE, response = TRUE)

p3 <- predict.gam(model, pdat1, 
                  se.fit = TRUE)

# # Get the deviance residuals
deviance_residuals <- residuals(model, type = "working")

# fv <- predict(model,type="terms") ## get term estimates
#      
# ## compute partial residuals for first smooth...          
# deviance_residuals <- residuals(model,type="working", response = TRUE) + fv[,1]

#Bind them together with observed vals

pdat <- cbind(pdat1, predicted = p2$fit, predicted_nr = p3$fit, se2 = p2$se.fit, observed, 
              deviance_residuals)

#Get upper and lower bounds for predicted values (replace with bootstraps for selected model)

df.res <- df.residual(model)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
pdat <- transform(pdat,
                  upper_pred = predicted_nr + (crit.t * se2),
                  lower_pred = predicted_nr - (crit.t * se2))

# Calculate the derivatives and add that too
derivs_1 <- as.data.frame(derivatives(model, order = 1, 
                   n = nrow(data), interval = "confidence") ) %>% 
                   dplyr::select(derivative, lower, upper) %>% 
                   rename(first_derivative = derivative,
                          first_lower = lower,
                          first_upper = upper)

# Calculate the derivatives and add that too
derivs_2 <- as.data.frame(derivatives(model, order = 2, 
                   n = nrow(data), interval = "confidence") ) %>% 
                   dplyr::select(derivative, lower, upper) %>% 
                   rename(second_derivative = derivative,
                          second_lower = lower,
                          second_upper = upper)

# derivs_2_fun <- splinefun(x = data$annual_time_step, y = pdat$predicted)
# 
# derivs_2_2 <- derivs_2_fun(data$annual_time_step, deriv = 2)

# Bind it all together
temp <- cbind(pdat, derivs_1, derivs_2)

# Get the indicator we are modeling
indicator <- data$indicator[1]
#scenario <- data$scenario[1]

# Make the final plot data
test_gam_data <- temp %>% 
                 mutate(first_significant = ifelse(first_lower <= 0 & 
                                                  first_upper >= 0, FALSE, TRUE),
                        positive_trend = ifelse(first_significant == TRUE & 
                                                 first_derivative > 0,
                                            predicted_nr,NA),
                        negative_trend = ifelse(first_significant == TRUE & 
                                                 first_derivative < 0,
                                            predicted_nr, NA),
                        positive_der_1 = ifelse(first_significant == TRUE & 
                                                  first_derivative > 0,
                                            first_derivative,NA),
                        negative_der_1 = ifelse(first_significant == TRUE & 
                                                  first_derivative < 0,
                                            first_derivative, NA),
                        second_significant = ifelse(second_lower <= 0 & 
                                                  first_upper >= 0, FALSE, TRUE),
                        positive_tp = ifelse(second_significant == TRUE & 
                                             second_derivative > 0,
                                            predicted_nr,NA),
                        negative_tp = ifelse(second_significant == TRUE & 
                                            second_derivative < 0,
                                            predicted_nr, NA),
                        positive_der_2 = ifelse(second_significant == TRUE & 
                                                second_derivative > 0,
                                            second_derivative,NA),
                        negative_der_2 = ifelse(second_significant == TRUE & 
                                                second_derivative < 0,
                                            first_derivative, NA),
                        indicator = indicator,
                        scenario = scenario,
                        kvalue = model$rank,
                        r2 = summary.gam(model)$r.sq) 

}
```

```{r plot test gam}

plot_test_gam <- function(gam_data) {

if(all(is.na(gam_data$positive_trend)) & 
           !all(is.na(gam_data$negative_trend))) {

gam_plot <- ggplot(data = gam_data) +
            geom_rect(aes(xmin = 95, xmax = 105,
                          ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4) +
            geom_rect(aes(xmin = 195, xmax = 205,
                          ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4)+
            geom_vline(xintercept=c(100,200), linetype = "dotted") +
            #geom_point(aes(x = annual_time_step, y = deviance_residuals), alpha = 0.2) +
            geom_point(aes(x = annual_time_step, y = observed), alpha = 0.2) +
  # geom_point(aes(x = annual_time_step, y = positive_tp), shape = 8, size = 3, col = "blue") +
  # geom_point(aes(x = annual_time_step, y = negative_tp), shape = 8, size = 3, col = "red") +
            geom_rug(sides="b", aes(x = annual_time_step)) +
            # Plot the smoothed indicator line
            geom_line(aes(x = annual_time_step, y = predicted_nr)) +
            # Add the confidence intervals
            geom_ribbon(aes(x = annual_time_step, ymin = lower_pred, ymax = upper_pred),
                        alpha = 0.3) +
            # Add the significant trends based on first derivative
            #geom_line(aes(x = annual_time_step, y = positive_trend), col = "blue") +
            geom_line(aes(x = annual_time_step, y = negative_trend), col = neg_col) +
            labs(y = gam_data$indicator[1],
                 title = paste(gam_data$scenario[1], 
                               gam_data$indicator[1], "k =", 
                               gam_data$kvalue[1], sep = " ")) +
            plot_theme

} else if(!all(is.na(gam_data$positive_trend))& 
           all(is.na(gam_data$negative_trend))) {

gam_plot <- ggplot(data = gam_data) +
  geom_rect(aes(xmin = 95, xmax = 105,
                          ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4) +
            geom_rect(aes(xmin = 195, xmax = 205,
                          ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4)+
            geom_vline(xintercept=c(100,200), linetype = "dotted") +
            #geom_point(aes(x = annual_time_step, y = deviance_residuals), alpha = 0.2) +
            geom_point(aes(x = annual_time_step, y = observed), alpha = 0.2) +
            geom_rug(sides="b", aes(x = annual_time_step)) +
            # Plot the smoothed indicator line
            geom_line(aes(x = annual_time_step, y = predicted_nr)) +
            # Add the confidence intervals
            geom_ribbon(aes(x = annual_time_step, ymin = lower_pred, ymax = upper_pred),
                        alpha = 0.3) +
            # Add the significant trends based on first derivative
            geom_line(aes(x = annual_time_step, y = positive_trend), col = pos_col) +
            #geom_line(aes(x = annual_time_step, y = negative_trend), col = "red") +
            labs(y = gam_data$indicator[1],
                 title = paste(gam_data$scenario[1], 
                               gam_data$indicator[1], "k =", 
                               gam_data$kvalue[1], sep = " ")) +
            plot_theme


} else if (all(is.na(gam_data$positive_trend)) & 
           all(is.na(gam_data$negative_trend))) {

gam_plot <- ggplot(data = gam_data) +
  geom_rect(aes(xmin = 95, xmax = 105,
                          ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4) +
            geom_rect(aes(xmin = 195, xmax = 205,
                          ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4)+
            geom_vline(xintercept=c(100,200), linetype = "dotted") +
            #geom_point(aes(x = annual_time_step, y = deviance_residuals), alpha = 0.2) +
            geom_point(aes(x = annual_time_step, y = observed), alpha = 0.2) +
            geom_rug(sides="b", aes(x = annual_time_step)) +
            # Plot the smoothed indicator line
            geom_line(aes(x = annual_time_step, y = predicted_nr)) +
            # Add the confidence intervals
            geom_ribbon(aes(x = annual_time_step, ymin = lower_pred, ymax = upper_pred),
                        alpha = 0.3) +
            # Add the significant trends based on first derivative
            #geom_line(aes(x = annual_time_step, y = positive_trend), col = "blue") +
            #geom_line(aes(x = annual_time_step, y = negative_trend), col = "red") +
            labs(y = gam_data$indicator[1],
                 title = paste(gam_data$scenario[1], 
                               gam_data$indicator[1], "k =", 
                               gam_data$kvalue[1], sep = " ")) +
            plot_theme


} else {
  
gam_plot <- ggplot(data = gam_data) +
  geom_rect(aes(xmin = 95, xmax = 105,
                          ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4) +
            geom_rect(aes(xmin = 195, xmax = 205,
                          ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4)+
            geom_vline(xintercept=c(100,200), linetype = "dotted") +
            #geom_point(aes(x = annual_time_step, y = deviance_residuals), alpha = 0.2) +
            geom_point(aes(x = annual_time_step, y = observed), alpha = 0.2) +
            geom_rug(sides="b", aes(x = annual_time_step)) +
            # Plot the smoothed indicator line
            geom_line(aes(x = annual_time_step, y = predicted_nr)) +
            # Add the confidence intervals
            geom_ribbon(aes(x = annual_time_step, ymin = lower_pred, ymax = upper_pred),
                        alpha = 0.3) +
            # Add the significant trends based on first derivative
            geom_line(aes(x = annual_time_step, y = positive_trend), col = pos_col) +
            geom_line(aes(x = annual_time_step, y = negative_trend), col = neg_col) +
            labs(y = gam_data$indicator[1],
                 title = paste(gam_data$scenario[1], 
                               gam_data$indicator[1], "k =", 
                               gam_data$kvalue[1], sep = " ")) +
            plot_theme

return(gam_plot)

  }
}


```

```{r compare trends}
# Loop through each model and identify which time steps show a significant 
# positive or negative trend
# list_of_model_data <- test_gam_data

compare_trends <- function(list_of_model_data) {

# Get the number of models we need consensus across
l <- length(list_of_model_data)

trend_data <- list()

for (j in seq_along(list_of_model_data)) {
  
trend_data[[j]] <- list_of_model_data[[j]] %>% 
                   dplyr::select(annual_time_step, positive_trend,
                              negative_trend, indicator, scenario,
                              first_derivative, kvalue) %>% 
                   mutate(k_value = kvals[[j]],
                          direction = ifelse(!is.na(positive_trend),
                                             "positive",
                                            ifelse(!is.na(negative_trend),
                                             "negative", NA)))
}

# Convert  into a single data frame
trend_df_all <- do.call(rbind, trend_data)


# Check which time steps show a significant trend regardless of model
# k value (ie are the robust significant changes at the expected time points?)

# direction_df <- trend_df_all %>% 
#                 dplyr::select(annual_time_step, k_value, direction, positive_trend,
#                               negative_trend, indicator, scenario, first_derivative) %>% 
#                 group_by(annual_time_step) %>% 
#                 mutate(positive_across_all_models = sum(direction == "positive", na.rm = TRUE),
#                        negative_across_all_models = sum(direction == "negative", na.rm = TRUE)) %>% 
#                 filter(positive_across_all_models == l|
#                       negative_across_all_models == l) #%>% 
#                 # mutate(positive_across_all_models = ifelse(positive_across_all_models == l, 1, 0),
                #        negative_across_all_models = ifelse(negative_across_all_models == l, 1, 0))



# Check which time steps show a significant trend regardless of model
# k value (ie are the robust significant changes at the expected time points?)
direction_df <- trend_df_all %>% 
                dplyr::select(annual_time_step, k_value, direction, positive_trend,
                              negative_trend, indicator, scenario, first_derivative) %>% 
                group_by(annual_time_step) %>% 
                summarise(positive_across_all_models = sum(direction == "positive"),
                          negative_across_all_models = sum(direction == "negative")) %>% 
                filter(positive_across_all_models == l|
                       negative_across_all_models == l) #%>% 
                # mutate(positive_across_all_models = ifelse(positive_across_all_models == l, 1, 0),
                #        negative_across_all_models = ifelse(negative_across_all_models == l, 1, 0))

return(direction_df)

}

```

```{r bootstrap selected model}

bootstrap_selected_model <- function(data, model, model_data, numboots) {

bootstrap_mods <- list()
bootstrap_mod_data <- list()
replicate <- list()

for (k in 1:numboots) {
        
# Take k number of random samples from the input data
replicate[[k]] <- slice_sample(data, 
                          prop = 1, replace = TRUE) 
        

# Fit the model with the data
bootstrap_mods[[k]] <- gam(indicator_score ~ s(annual_time_step, k = model$rank),
          select = TRUE,
          method = "GCV.Cp",
          data = replicate[[k]])

# Get the predicted values etc

obs <- replicate[[k]]$indicator_score

# Make a dataframe of predictor vals (ie timesteps)

pdat1 <- data.frame(annual_time_step = seq(1,nrow(data),1))

# Get predicted values for each time step
p2 <- predict.gam(bootstrap_mods[[k]], pdat1,
                  se.fit = TRUE, response = TRUE)

# Get the deviance residuals
deviance_residuals <- residuals(bootstrap_mods[[k]], type = "deviance", 
                                response = TRUE)

#Bind them together with observed vals

pdat <- cbind(pdat1, predicted = p2$fit, se2 = p2$se.fit, obs, 
              deviance_residuals) %>%  
                  mutate(replicate = k)

# Calculate the derivatives and add that too
gratia_derivs_1 <- as.data.frame(derivatives(bootstrap_mods[[k]], order = 1, 
                   n = nrow(data), interval = "confidence") ) %>% 
                   dplyr::select(derivative, lower, upper) %>% 
                   rename(first_derivative = derivative,
                          first_lower = lower,
                          first_upper = upper)

# Calculate the derivatives and add that too
gratia_derivs_2 <- as.data.frame(derivatives(bootstrap_mods[[k]], order = 2, 
                   n = nrow(data), interval = "confidence") ) %>% 
                   dplyr::select(derivative, lower, upper) %>% 
                   rename(second_derivative = derivative,
                          second_lower = lower,
                          second_upper = upper)

# Bind it all together
bootstrap_mod_data[[k]] <- cbind(pdat, gratia_derivs_1, gratia_derivs_2)

print(k)

}

ci_df <- do.call(rbind, bootstrap_mod_data) %>% 
             #Group by timestep
             group_by(annual_time_step) %>% 
             arrange(predicted) %>% 
             summarise(predicted_lower = quantile(predicted, 
                                      probs = 0.025),
                       predicted_upper = quantile(predicted, 
                                      probs = 0.975)) 

first_deriv_df <- do.call(rbind, bootstrap_mod_data) %>% 
             #Group by timestep
             group_by(annual_time_step) %>% 
             # Arrange first deriv values from each bootstrap in order
             arrange(first_derivative) %>% 
             # Set bottom 25th and top 75th quantiles as the lower and upper CIs of the first derivative
             summarise(first_lower = quantile(first_derivative, 
                                      probs = 0.025),
                       first_upper = quantile(first_derivative, 
                                      probs = 0.975)) %>% 
             # Add in the original first derivative from the full dataset
             merge(model_data[c("annual_time_step", "predicted",
                                "first_derivative")],
                   by = "annual_time_step") %>% 
             # Check if the derivative CIs include zero (if so trend is not significant)
             mutate(significant = ifelse(first_lower < 0 & first_upper > 0, 
                                         FALSE, TRUE),
             # If trend is significant and first deriv > 0, get the the predicted indicator 
             # trend values that are positive
                    positive_trend = ifelse(significant == TRUE & first_derivative > 0,
                                            predicted,NA),
             # If trend is significant and first deriv > 0, get the the predicted indicator 
             # trend values that are negative
                    negative_trend = ifelse(significant == TRUE & first_derivative < 0,
                                            predicted, NA),
             # If trend is significant and first deriv > 0, get the the predicted first 
             # derivative values that are positive
                    positive_der1 = ifelse(significant == TRUE & first_derivative > 0,
                                            first_derivative,NA),
             # If trend is significant and first deriv > 0, get the the predicted first 
             # derivative values that are negative
                    negative_der1 = ifelse(significant == TRUE & first_derivative < 0,
                                            first_derivative, NA)) %>% 
            dplyr::select(-predicted)

second_deriv_df <- do.call(rbind, bootstrap_mod_data) %>% 
             #Group by timestep
             group_by(annual_time_step) %>% 
             # Order second derivative values 
             arrange(second_derivative) %>% 
             summarise(second_lower = quantile(second_derivative, 
                                      probs = 0.025),
                       second_upper = quantile(second_derivative, 
                                      probs = 0.975))%>% 
             # Add in the original first derivative from the full dataset
             merge(model_data[c("annual_time_step", "predicted",
                                "second_derivative")],
                   by = "annual_time_step") %>% 
             mutate(significant_2 = ifelse(second_lower < 0 & second_upper > 0, 
                                         FALSE, TRUE),
                    positive_tp = ifelse(significant_2 == TRUE & second_derivative > 0,
                                            predicted,NA),
                    negative_tp = ifelse(significant_2 == TRUE & second_derivative < 0,
                                            predicted, NA),
                    positive_der2 = ifelse(significant_2 == TRUE & second_derivative > 0,
                                            second_derivative,NA),
                    negative_der2 = ifelse(significant_2 == TRUE & second_derivative < 0,
                                            second_derivative, NA)) %>% 
            dplyr::select(-predicted)


new <- model_data %>% 
     dplyr::select(annual_time_step, observed, predicted, deviance_residuals, 
                   indicator, scenario, kvalue) %>% 
     merge(ci_df, by ="annual_time_step") %>% 
     merge(first_deriv_df, by ="annual_time_step") %>% 
     merge(second_deriv_df, by ="annual_time_step") #%>% 
    # merge(model_data[c("annual_time_step", "kvalue")], by = "annual_time_step")

}


```

```{r plot bootstrapped model}

plot_bootstrapped_model <- function(data, ylimits){
  
indicator <- data$indicator[1]

boot_base_plot <- ggplot(data = data) +
                  geom_rect(aes(xmin = 95, xmax = 105,
                                ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4) +
                  geom_rect(aes(xmin = 195, xmax = 205,
                                ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4)+
                  geom_point(aes(x = annual_time_step, y = observed), 
                                       alpha = 0.2, size = 1) +
                  # geom_line(aes(x = annual_time_step, y = observed), 
                  #           alpha = 0.2) +
                  geom_line(aes(x = annual_time_step, y = predicted)) +
                  geom_ribbon(aes(x = annual_time_step, ymin = predicted_lower, 
                                            ymax = predicted_upper),
                                        alpha = 0.4) +
                  labs(x = "Time (years)",
                        y = indicator) + 
                  geom_vline(xintercept=c(100,200), linetype = "dotted") +
                  coord_cartesian(ylim = ylimits)
                # + annotate("text", x = 295, y = 1.1, 
                #            label = paste("Dev. explained =",
                #                          dev_explained,sep = " "), 
                #            size = 4)
if(all(is.na(data$positive_trend))) {
boot_plot <-  boot_base_plot +
              # geom_line(aes(x = annual_time_step, y = negative_trend), 
              #           col = neg_col, size = 1) +
              plot_theme 
  
} else if(all(is.na(data$robust_positive_trend))) {
boot_plot <- boot_base_plot +
  #  geom_line(aes(x = annual_time_step, y = positive_trend), col = pos_col, 
  #            size = 1) +
  # geom_line(aes(x = annual_time_step, y = negative_trend), col = neg_col, 
  #            size = 1) +
  geom_line(aes(x = annual_time_step, y = robust_negative_trend), 
            col = neg_col, size = 4) +
  plot_theme  
 
  
} else if (all(is.na(data$robust_negative_trend))) {
boot_plot <- boot_base_plot +
  #  geom_line(aes(x = annual_time_step, y = positive_trend), col = pos_col, 
  #            size = 1) +
  # geom_line(aes(x = annual_time_step, y = negative_trend), col = neg_col, 
  #            size = 1) +
  geom_line(aes(x = annual_time_step, y = robust_positive_trend), 
            col = pos_col, size = 4) +
  plot_theme 
 
} else {
  boot_plot <- boot_base_plot +
  # geom_line(aes(x = annual_time_step, y = positive_trend), col = pos_col, 
  #            size = 1) +
  # geom_line(aes(x = annual_time_step, y = negative_trend), col = neg_col, 
  #            size = 1) +
  geom_line(aes(x = annual_time_step, y = robust_positive_trend), 
            col = pos_col, size = 4) +
  geom_line(aes(x = annual_time_step, y = robust_negative_trend), 
            col = neg_col, size = 4) +
  plot_theme 
  
  return(boot_plot)
  
  }
}
```

# Inputs

```{r data, results=FALSE }

# Set up paths ----

location <- 'Serengeti'

indicators_project <- "N:/Quantitative-Ecology/Indicators-Project"

# Analysis inputs are the outputs of 2_calculate_madingley_indicators.R

analysis_inputs <- "N:/Quantitative-Ecology/Indicators-Project/Serengeti/Outputs_from_indicator_code/Indicator_outputs/general/"

# Inputs ----

# disable scientific notation

options(scipen = 999)

# Specify the date of inputs you want to use

input_date <- "2021-09-30"

# Specify how many bootstraps you want to use

boots <- 1000

# Specify how many influential species you want to plot

n <- 6

# Size of test gam plots

t_width <- 20
t_height <- 10

# Make colours for pos and neg trends

# Purple and green?
# neg_col <- "#440154FF"
# pos_col <- "#2A788EFF"

# Pink and purple
# neg_col <- "#C5407EFF"
# pos_col <- "#2D0594FF"

# Red and blue
neg_col <- "#A51301FF"
pos_col <- "#3AA2FCFF"

# Get date to label outputs

output_date <- Sys.Date() 

scenarios_title <- list("Baseline", "Land use", 
                  "Carnivore harvesting", 
                  "Herbivore harvesting")

scenarios_title_2 <- c("Baseline","Baseline","Harvesting primary producers","Harvesting primary producers",
                       "Harvesting carnivores","Harvesting carnivores",
                       "Harvesting herbivores", "Harvesting herbivores")

disturbance_string <- c("pre-disturbance", "disturbance", "post-disturbance")

disturbance_factor <- factor(disturbance_string, ordered = TRUE,
                              levels = c("pre-disturbance", 
                                         "disturbance", 
                                         "post-disturbance"))

# Set up output folders

## Include a folder to store the version of inputs used to get the outputs

analysis_inputs_folder <- file.path(indicators_project,  
                           "/Serengeti/Outputs_from_analysis_code/Analysis_inputs",
                           output_date)

if( !dir.exists( file.path(analysis_inputs_folder) ) ) {
  dir.create( file.path(analysis_inputs_folder), recursive = TRUE )
  
}

analysis_outputs_folder <- file.path(indicators_project,  
                           "/Serengeti/Outputs_from_analysis_code/Analysis_outputs",
                           output_date)

if( !dir.exists( file.path(analysis_outputs_folder) ) ) {
  dir.create( file.path(analysis_outputs_folder), recursive = TRUE )
  
}

manuscript_plots_folder <- file.path(indicators_project, 
                                     "/Serengeti/Outputs_from_analysis_code/manuscript_plots_folder",
                                   output_date)

if( !dir.exists( file.path(manuscript_plots_folder) ) ) {
  dir.create( file.path(manuscript_plots_folder), recursive = TRUE )
  
}

supporting_info_plots_folder <- file.path(indicators_project, 
                                     "/Serengeti/Outputs_from_analysis_code/supporting_info_plots_folder",
                                   output_date)

if( !dir.exists( file.path(supporting_info_plots_folder) ) ) {
  dir.create( file.path(supporting_info_plots_folder), recursive = TRUE )
  
}



# Load indicator > scenario level data ----

indicators_all_df <- readRDS(file.path(analysis_inputs, input_date, "all_indicators_output_dataframe.rds"))

indicators_all_list <- flatten(readRDS(file.path(analysis_inputs,input_date, "all_indicators_output_list.rds")))

# Get list of indicators

indicators <- unique(indicators_all_df$indicator)

# Get list of scenarios

scenarios <- unique(indicators_all_df$scenario)

# Save a copy of the inputs used to create outputs

write.csv(indicators_all_df, file.path(analysis_inputs_folder,
                                       paste(output_date, "input_data.csv",
                                             sep = "_")))
# Load red list data

scenario_redlist_data_sampled <- readRDS(file.path(analysis_inputs, input_date, "scenario_redlist_data_annual_7.rds"))

# Load autotroph data

auto_annual <- readRDS(file.path(analysis_inputs, input_date, 
                                 "scenario_auto_annual_6.rds"))
# Get groups

groups <- read.csv(file.path(analysis_inputs, input_date, "groups.csv"))

# Add 'harvested' tag

groups <- groups %>% 
          mutate(harvested = ifelse(group_id == "10.67", "(directly harvested)",
                             ifelse(group_id == "10.68", "(directly harvested)",
                             ifelse(group_id == "10.69", "(directly harvested)",
                             ifelse(group_id == "11.67", "(directly harvested)",
                             ifelse(group_id == "11.68", "(directly harvested)",
                             ifelse(group_id == "11.69", "(directly harvested)", 
                                    " ")))))))

species <- read.csv("N:/Quantitative-Ecology/Indicators-Project/Serengeti/Outputs_from_indicator_code/Indicator_outputs/general/2021-09-22/model_species.csv")

# Get 1 spp per group
example_species <- species %>% 
                   filter(!is.na(common_name)) %>% 
                   group_by(group_id) %>% 
                   slice(1)

estimated_gen_lengths <- read.csv("N:/Quantitative-Ecology/Indicators-Project/Serengeti/Outputs_from_indicator_code/Indicator_outputs/general/2021-09-22/estimated_generation_lengths.csv")

```


```{r prep data, results = FALSE}
# Standardize & difference the data as per Bestelmeyer 2011

indicators_all_df <- indicators_all_df %>% 
                     group_by(indicator, scenario) %>% 
  filter(indicator == "RLI annual"|
         indicator == "LPI") %>% 
                     mutate(indicator_score_std = standardize(indicator_score),
                            indicator_score_diff = indicator_score_std - 
                             lag(indicator_score_std, default = 0)) %>% 
                     mutate(indicator = ifelse(indicator == "RLI annual", "RLI",
                                               indicator)) %>% 
                    mutate(scenario_indicator = paste(scenario, indicator, 
                                                       sep = "_"),
                            variance = rollapply(indicator_score_diff,
                               10,
                               var,
                               na.rm = TRUE,
                               partial = TRUE,
                               align = "left"),
                            disturbance = as.integer(ifelse(annual_time_step > 99 &
                                                 annual_time_step < 201,
                                                 1, 0)),
                            disturbance_factor = as.factor(ifelse(disturbance == 1,
                                                 "disturbance", 
                                                 "no disturbance")),
                            years_since_disturbance = ifelse(annual_time_step < 100,
                                                            1, (annual_time_step - 100)),
                            disturbance_phase = as.integer(ifelse(annual_time_step < 100,
                                                                  1,
                                                 ifelse(annual_time_step > 99 &
                                                 annual_time_step < 201,
                                                 2, 3)))) %>%
                     ungroup(.)

# Split into a list of scenarios then indicators

scenario_indicators <- split(indicators_all_df, indicators_all_df$scenario)

# Or vice versa

indicator_scenarios <- split(indicators_all_df, indicators_all_df$indicator)

# Single indicator, single scenario

scenario_indicator_single <- split(indicators_all_df, indicators_all_df$scenario_indicator)

# Make a test df of one scenario, one indicator for building loop content

test_df <- indicators_all_df %>% 
           filter(indicator == "total abundance harvested") %>% 
           filter(scenario != "000_Baseline")

# Get the ylimits for indicator plots

# Specify y - limits of indicators

df <- indicators_all_df %>% 
      dplyr::filter(indicator  == "RLI") %>% 
      filter(scenario != "000_Baseline")

rlmin <- min(df$indicator_score) 
rlmax <- max(df$indicator_score)
rli_lims <- c(rlmin,rlmax)

df <- indicators_all_df %>% 
      dplyr::filter(indicator  == "LPI") %>% 
      filter(scenario != "000_Baseline")

lpmin <- min(df$indicator_score)
lpmax <- max(df$indicator_score)
lpi_lims <- c(lpmin,lpmax)



```

```{r get spp number}

# Check the number of functional species present in each scenario

out <- list()

for (i in seq_along(scenario_redlist_data_sampled)) {
  
  n <- length(unique(scenario_redlist_data_sampled[[i]]$group_id))
  sc <- scenarios_title[[i]]
  
  out[[i]] <- data.frame(scenario = sc, n_functional_species = n)
         
}

no_func_spp_df <- do.call(rbind, out)

no_func_spp_df

```

# Species gams

First derivatives show the rate of change in the indicator at a specific time
point. Values = 0 signify no trend, values > 0 signify a positive trend, and
values < 0 signify a negative trend.

"The second derivative of the trend curve I(t) at time t is a measure of the curvature of I at that time. If the second derivative is greater than zero, the curve is turning upward. If it is less than zero, the curve is turning downward. The magnitude of the second derivative signifies the tightness of the curvature. Values of approx 0 indicate the curve is linear and changing at a steady state. Years in which the second derivative is markedly different from zero are those in which something is happening to alter the rate of population change." (Fewster et al 2000)

```{r species gams}

species_gams <- list()
species_gam_data <- list()
species_gam_plots <- list()

for (i in seq_along(scenario_redlist_data_sampled)) {
  
scenario_data <- scenario_redlist_data_sampled[[i]]

group_ids <- unique(scenario_data$group_id)

spp_mods <- list()
spp_data <- list()
spp_plots <- list()


  for (j in seq_along(group_ids)) {

  species_data <- scenario_data %>% 
                filter(group_id == group_ids[[j]]) %>% 
                mutate(std_abundance = standardize(ave_abundance)) %>% 
                ungroup(.)

  spp_mods[[j]] <- gam(std_abundance ~ s(annual_time_step, k = 10),
         select = TRUE,
         method = "GCV.Cp",
         data = species_data)

  spp_data[[j]] <- get_species_gam_data(species_data, spp_mods[[j]], 
                                              scenarios[[i]])

  spp_plots[[j]] <- plot_test_gam(spp_data[[j]])
  
  }

names(spp_plots) <- group_ids

df <- do.call(rbind, spp_data)

species_gam_data[[i]] <- df

species_gam_plots[[i]] <- spp_plots

}

```

``` {r influential species}

influential_species_plots <- list()
influential_species_data <- list()
all_responses <- list()
fgs <- list()

for (i in seq_along(species_gam_data)) {


temp <- species_gam_data[[i]] %>% 
        merge(groups[c("group_id", "nutrition_source", "harvested")], 
              by.x = "indicator",
              by.y = "group_id") %>% 
        #Get only the species where significant trends are detected
        filter(first_significant == TRUE) %>% 
        #Get only the species with significant trends at start or end of impact
        filter(annual_time_step >= 95 &
               annual_time_step <= 105|
               annual_time_step >= 195 &
               annual_time_step <= 205) %>% 
        dplyr::select(indicator, annual_time_step, 
                      predicted, first_derivative, nutrition_source) %>% 
        #Add a new variable that denotes whether we are looking at impact start or end event
        mutate(impact = ifelse(annual_time_step >= 95 &
               annual_time_step <= 105, "Impact start",
               ifelse(annual_time_step >= 195 &
               annual_time_step <= 205, "Impact stop", NA)))  
  
# Get start ----

# Look at response to impact start

temp2 <- temp %>% 
         filter(impact == "Impact start") %>% 
         dplyr::select(-annual_time_step) %>% # Remove time steps
         mutate(absolute_fd = abs(first_derivative)) # convert 1st deriv to absolute value
       
# idk what tf is going on here but arrange is not working as it should, so
# had to separate it from the rest of the pipe

temp3 <- temp2 %>% 
         arrange(desc(absolute_fd))

all_start <- temp3 %>% 
         group_by(indicator) %>% # group by spp
         filter(absolute_fd == max(absolute_fd)) # get the highest value per spp

if(scenarios_title[[i]] == "Carnivore harvesting") {

x <- all_start[1:n,] # Get n most influential spp

harv <- all_start %>% 
        filter(indicator == "11.67"|
                indicator == "11.68" )

start <-rbind(x, harv)

} else {

start <- all_start[1:n,] # Get n most influential spp

}

rm(temp2, temp3)

# Get stop ----

# Look at response to impact start

temp2 <- temp %>% 
         filter(impact == "Impact stop") %>% 
         dplyr::select(-annual_time_step) %>% # Remove time steps
         mutate(absolute_fd = abs(first_derivative)) # convert 1st deriv to absolute value
       
# idk what tf is going on here but arrange is not working as it should, so
# had to separate it from the rest of the pipe

temp3 <- temp2 %>% 
         arrange(desc(absolute_fd))

all_stop <- temp3 %>% 
         group_by(indicator) %>% # group by spp
         filter(absolute_fd == max(absolute_fd)) # get the highest value per spp

stop <- all_stop[1:n,] # Get n most influential spp

influential_species_data[[i]] <- rbind(start, stop) 

all_responses[[i]] <- rbind(all_start, all_stop)

# Add the harvested groups if they're not already there

if(scenarios_title[[i]] == "Carnivore harvesting") {
  
  hg <- c("11.67", "11.68", influential_species_data[[i]]$indicator)
  fgs[[i]] <- unique(hg)
  
} else if(scenarios_title[[i]] == "Herbivore harvesting") {
  
  hg <- c("10.67", "10.68", influential_species_data[[i]]$indicator)
  fgs[[i]] <- unique(hg)
  
} else {

fgs[[i]] <- unique(influential_species_data[[i]]$indicator)

}

influential_species_plots[[i]] <- species_gam_plots[[i]][fgs[[i]]] 

#walk(influential_species_plots[[i]], print)

}

```

```{r influential_species_plots}

influential_spp_plots <- list()

for (i in seq_along(species_gam_data)) {

fg <- influential_species_data[[i]]$indicator

data <- species_gam_data[[i]][species_gam_data[[i]]$indicator %in% fg,]

temp <- data %>% 
        merge(groups[c("group_id", "nutrition_source", "mass_upper", 
                       "harvested")], 
              by.x = "indicator",
              by.y = "group_id") %>% 
        filter(annual_time_step < 293) %>% 
        merge(influential_species_data[[i]][c("indicator", "impact")], 
              by = "indicator") %>% 
        mutate(lower_kg = mass_upper/1000,
               label = paste(lower_kg, "kg", nutrition_source, 
                             "(", impact, ")", indicator,  sep = " ")) %>% 
        arrange(impact,lower_kg)

influential_spp_plots[[i]] <- ggplot(temp) +
        geom_line(aes(annual_time_step, predicted, col = impact)) +
        geom_line(aes(x = annual_time_step, y = positive_trend,
                      col = impact),
                  col = "blue", size = 1) +
        geom_line(aes(x = annual_time_step, y = negative_trend,
                      col = nutrition_source),
                  col = "red", size = 1) +
        geom_point(aes(x = annual_time_step, y = observed, group = indicator,
                       col = impact),
                                        alpha = 0.1,
                   size = 1) +
        scale_color_manual(values = c(pos_col, neg_col)) +
        scale_fill_manual(values = c(pos_col, neg_col)) +
        geom_ribbon(aes(x = annual_time_step, 
                        ymin = lower_pred, 
                        ymax = upper_pred, 
                        group = indicator),
                                        alpha = 0.3) +
                  labs(x = "Time (years)",
                        y = "Standardized abundance") + 
        geom_vline(xintercept=c(100,200), linetype = "dotted") +
        facet_wrap( ~ label, ncol = 2) +
        plot_theme

rm(data, temp, fg)

}

walk(influential_spp_plots, print)

```

```{r select influential spp}

spp_plots <- list()

for (i in seq_along(influential_species_data)) {

title <-  scenarios_title[[i]]

if( title == "Baseline") {
  
start_fgs <- influential_species_data[[i]] %>% 
     filter(impact == "Impact start") %>% 
     dplyr::select(indicator) %>% 
     pull(.)
start_fgs <- start_fgs[1:3]

stop_fgs <- influential_species_data[[i]] %>% 
     filter(impact == "Impact stop") %>% 
     dplyr::select(indicator) %>% 
     pull(.)

stop_fgs <- stop_fgs[1:3]

} else if (title == "Land use") {
  
  start_fgs <- c("10.33","15.18.39", "15.18.53")
  stop_fgs <- c("10.47","14.17.54", "10.72")
  
} else if (title == "Carnivore harvesting") {
  
  start_fgs <- c("11.67","12.66", "10.72")
  stop_fgs <- c("15.18.25","13.16.53", "12.65")
  
} else if (title == "Herbivore harvesting") {
  
  start_fgs <- c("10.68","10.72", "10.76")
  stop_fgs <- c("14.17.38","12.73", "13.16.57")
  
} 

data <- species_gam_data[[i]][species_gam_data[[i]]$indicator %in% start_fgs,]

temp <- data %>% 
        merge(groups[c("group_id", "nutrition_source", "mass_upper", 
                       "harvested")], 
              by.x = "indicator",
              by.y = "group_id") %>% 
    # merge(example_species[c("group_id", "common_name")],
    #                                    by.x = "indicator",
    #            by.y = "group_id") %>% 
        filter(annual_time_step < 293) %>% 
        merge(influential_species_data[[i]][c("indicator", "impact")], 
              by = "indicator") %>% 
        filter(impact == "Impact start") %>%
        mutate(lower_kg = mass_upper/1000,
               label = paste(lower_kg, "kg", nutrition_source, 
                             "(", indicator, ")", harvested, sep = " "),
               impact = "Impact start") %>% 
        arrange(impact,lower_kg)



start_plot <- ggplot(temp) +
            geom_rect(aes(xmin = 95, xmax = 105,
                                ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4) +
            geom_rect(aes(xmin = 195, xmax = 205,
                                ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4)+
        geom_line(aes(annual_time_step, predicted)) +
        geom_line(aes(x = annual_time_step, y = positive_trend),
                  col = pos_col, size = 2) +
        geom_line(aes(x = annual_time_step, y = negative_trend,
                      col = nutrition_source),
                  col = neg_col, size = 2) +
        geom_point(aes(x = annual_time_step, y = observed, group = indicator),
                                        alpha = 0.1,
                   size = 0.5) +
        scale_color_manual(values = c(pos_col, neg_col)) +
        scale_fill_manual(values = c(pos_col, neg_col)) +
        geom_ribbon(aes(x = annual_time_step, 
                        ymin = lower_pred, 
                        ymax = upper_pred, 
                        group = indicator),
                                        alpha = 0.3) +
                  labs(x = "Time (years)",
                        y = "Standardized abundance") + 
        geom_vline(xintercept=c(100,200), linetype = "dotted") +
        facet_wrap(~ label, nrow = 3) +
        theme(panel.background = element_blank(),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              legend.position = "bottom",
              legend.key.size = unit(0.25, 'cm'),
              plot.title = element_text(size = 10, face = "bold"),
              legend.title=element_text(size=6), 
              legend.text=element_text(size=5),
              axis.line = element_line(colour = "black"),
              axis.title.x = element_text(size=8),
              axis.title.y = element_text(size=8),
              axis.text.x = element_text(size=8),
              axis.text.y = element_text(size=8),
              axis.ticks.x = element_blank(), 
              axis.ticks.y = element_blank(),
              strip.text.x = element_text(size = 6))

data <- species_gam_data[[i]][species_gam_data[[i]]$indicator %in% stop_fgs,]

temp <- data %>% 
        merge(groups[c("group_id", "nutrition_source", "mass_upper", 
                       "harvested")], 
              by.x = "indicator",
              by.y = "group_id") %>% 
  # merge(example_species[c("group_id", "common_name")],
  #                                      by.x = "indicator",
  #              by.y = "group_id") %>% 
        filter(annual_time_step < 293) %>% 
        merge(influential_species_data[[i]][c("indicator", "impact")], 
              by = "indicator") %>% 
        filter(impact == "Impact stop") %>% 
        mutate(lower_kg = mass_upper/1000,
               label = paste(lower_kg, "kg", nutrition_source, 
                             "(", indicator, ")",harvested, sep = " ")) %>% 
        arrange(impact,lower_kg)

stop_plot <- ggplot(temp) +
        geom_rect(aes(xmin = 95, xmax = 105,
                                ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4) +
        geom_rect(aes(xmin = 195, xmax = 205,
                                ymin = -Inf, ymax = Inf), fill = "grey82", 
                            alpha = 0.4)+
        geom_line(aes(annual_time_step, predicted)) +
        geom_line(aes(x = annual_time_step, y = positive_trend),
                  col = pos_col, size = 2) +
        geom_line(aes(x = annual_time_step, y = negative_trend,
                      col = nutrition_source),
                  col = neg_col, size = 2) +
        geom_point(aes(x = annual_time_step, y = observed, group = indicator),
                   alpha = 0.1, size = 0.5) +
        scale_color_manual(values = c(pos_col, neg_col)) +
        scale_fill_manual(values = c(pos_col, neg_col)) +
        geom_ribbon(aes(x = annual_time_step, 
                        ymin = lower_pred, 
                        ymax = upper_pred, 
                        group = indicator),
                                        alpha = 0.3) +
                  labs(x = "Time (years)",
                        y = "Standardized abundance") + 
        geom_vline(xintercept=c(100,200), linetype = "dotted") +
        facet_wrap(~ label, nrow = 3) +
        theme(panel.background = element_blank(),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              legend.position = "bottom",
              legend.key.size = unit(0.25, 'cm'),
              plot.title = element_text(size = 10, face = "bold"),
              legend.title=element_text(size=6), 
              legend.text=element_text(size=5),
              axis.line = element_line(colour = "black"),
              axis.title.x = element_text(size=8),
              axis.title.y = element_text(size=8),
              axis.text.x = element_text(size=8),
              axis.text.y = element_text(size=8),
              axis.ticks.x = element_blank(), 
              axis.ticks.y = element_blank(),
              strip.text.x = element_text(size = 6))

spp_plots[[i]] <- plot_grid(start_plot, stop_plot, ncol = 2, align = "v")

ggsave(file.path(manuscript_plots_folder, paste(scenarios[[i]],
                                                "species_response_gams.png",
                                                sep = "_")),
       width = 14,
       height = 8,
       units = "cm",
       spp_plots[[i]])

rm(data, temp, stop_fgs, start_plot, stop_plot)

}

walk(spp_plots, print)

```

# All responses

```{r response plots}

response_boxplots <- list()

for (i in seq_along(all_responses)) {
  
bxplot_data <- all_responses[[i]] %>% 
               merge(groups[c("group_id", "functional_group_name", "mass_lower")], 
              by.x = "indicator",
              by.y = "group_id") %>% 
              mutate(mass_lower_kg = mass_lower/1000) %>% 
              group_by(functional_group_name) %>% 
              mutate(n = n_distinct(indicator)) %>% 
              ungroup(.) %>% 
              mutate(functional_group_name = paste(functional_group_name, 
                                                   "(", "n =", n, ")", sep = " "))

response_boxplots[[i]] <- ggplot(bxplot_data, aes(x = functional_group_name, 
                                    y = first_derivative)) +
                            geom_violin(alpha = 0.1, aes(col = functional_group_name)) +
            geom_point(aes(x = functional_group_name,
                           y = first_derivative,
                           fill = functional_group_name,
                           col = functional_group_name,
                           size = mass_lower_kg), alpha = 0.4) +
            #geom_jitter(aes(alpha = mass_upper_kg)) +
            geom_hline(yintercept = 0, linetype = "dotted") +
            labs(y = "Functional species response") +
            theme(panel.background = element_rect(fill = 'grey70'),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              legend.position = "bottom",
              legend.key.size = unit(0.25, 'cm'),
              plot.title = element_text(size = 10, face = "bold"),
              legend.title=element_text(size=7), 
              legend.text=element_text(size=6),
              axis.line = element_line(colour = "black"),
              axis.title.x = element_blank(),
              axis.title.y = element_blank(),
              axis.text.x = element_text(size=7),
              axis.text.y = element_text(size=7),
              axis.ticks.x = element_blank(), 
              axis.ticks.y = element_blank()) +
             facet_wrap(~impact) +
  scale_fill_viridis_d(guide = "none", option = "viridis") +
  scale_color_viridis_d(guide = "none",option = "viridis") +
  #scale_colour_hue(guide = "none") +
  scale_fill_hue(guide = "none")+ 
  scale_y_continuous(breaks = c(-0.08, 0, 0.08),
                     labels = c("Decreased \n in abundance",
                                "No change",
                                "Increased \n in abundance"),
                     limits = c(-0.1,0.1)) +
  labs(size = "Body size (kg)") +
  coord_flip()

ggsave(file.path(manuscript_plots_folder, paste(scenarios[[i]],
                                                "functional_group_boxplots.png",
                                                sep = "_")),
       width = 14,
       height = 8,
       units = "cm",
       response_boxplots[[i]])


}

walk(response_boxplots, print)

```


# Functional group gams

```{r fg gams}

fg_gams <- list()
fg_gam_data <- list()
fg_gam_plots <- list()

for (i in seq_along(scenario_redlist_data_sampled)) {
  
scenario_data <- scenario_redlist_data_sampled[[i]] %>% 
                 group_by(annual_time_step,functional_group_name) %>% 
                 mutate(fg_abundance = sum(ave_abundance, na.rm = TRUE)) %>% 
                 dplyr::select(annual_time_step, fg_abundance, functional_group_name) %>% 
                 distinct(.) %>% 
                 ungroup(.) %>% 
                 group_by(functional_group_name) %>% 
                 mutate(std_abundance = standardize(fg_abundance)) %>% 
                 ungroup(.)

fg_ids <- unique(scenario_data$functional_group_name)

fg_mods <- list()
fg_data <- list()
fg_plots <- list()


  for (j in seq_along(fg_ids)) {

  data <- scenario_data %>% 
          filter(functional_group_name == fg_ids[[j]]) %>% 
          rename(group_id = functional_group_name)
  
  fg_mods[[j]] <- gam(std_abundance ~ s(annual_time_step, k = 10),
         select = TRUE,
         method = "GCV.Cp",
         data = data)
  
  fg_data[[j]] <- get_species_gam_data(data, fg_mods[[j]], 
                                              scenarios[[i]])
  
  #fg_plots[[j]] <- plot_test_gam(fg_data[[j]])
  
  
  
  }

# names(fg_data) <- fg_ids
# names(fg_mods) <- fg_ids

df <- do.call(rbind, fg_data) %>% 
      rename(functional_group = indicator)

fg_gam_plots[[i]] <- ggplot(df) +
        geom_line(aes(annual_time_step, predicted)) +
        geom_line(aes(x = annual_time_step, y = positive_trend), 
                  col = "blue", size = 1) +
        geom_line(aes(x = annual_time_step, y = negative_trend), 
                  col = "red", size = 1) +
        geom_point(aes(x = annual_time_step, y = observed),
                                        alpha = 0.1,
                   size = 1) +
        geom_ribbon(aes(x = annual_time_step, 
                        ymin = lower_pred, 
                        ymax = upper_pred),
                                        alpha = 0.3) +
                  labs(x = "Time (years)",
                        y = "Standardized abundance",
                       title = scenarios[[i]]) + 
        geom_vline(xintercept=c(100,200), linetype = "dotted") +
        facet_wrap( ~ functional_group) +
        plot_theme

ggsave(file.path(manuscript_plots_folder, paste(scenarios[[i]],
                                                "functional_group_gams.png",
                                                sep = "_")),
       width = 10,
       height = 5,
       units = "cm",
       fg_gam_plots[[i]])

fg_gam_data[[i]] <- df

}

walk(fg_gam_plots, print)

```

# Trophic group gams

``` {r tg gams}

tg_gams <- list()
tg_gam_data <- list()
tg_gam_plots <- list()

for (i in seq_along(scenario_redlist_data_sampled)) {

auto <- auto_annual[[i]] %>% 
        filter(annual_time_step > 1) %>% 
        filter(annual_time_step < 293) %>% 
        mutate(functional_group_name = group_id) %>% 
        filter(group_id == "autotrophs")

all <- rbind(scenario_redlist_data_sampled[[i]], auto)

scenario_data <- all  %>% 
                 mutate(trophic_group = word(functional_group_name, 1)) %>% 
                 group_by(annual_time_step,trophic_group) %>% 
                 mutate(tg_abundance = sum(ave_abundance, na.rm = TRUE)) %>% 
                 dplyr::select(annual_time_step, tg_abundance, trophic_group) %>% 
                 distinct(.) %>% 
                 ungroup(.) %>% 
                 group_by(trophic_group) %>% 
                 mutate(std_abundance = standardize(tg_abundance)) %>% 
                 ungroup(.)

tg_ids <- unique(scenario_data$trophic_group)

tg_mods <- list()
tg_data <- list()
tg_plots <- list()

  for (j in seq_along(tg_ids)) {

  data <- scenario_data %>% 
          filter(trophic_group == tg_ids[[j]]) %>% 
          rename(group_id = trophic_group)
  
  tg_mods[[j]] <- gam(std_abundance ~ s(annual_time_step, k = 10),
         select = TRUE,
         method = "GCV.Cp",
         data = data)
  
  tg_data[[j]] <- get_species_gam_data(data, tg_mods[[j]], 
                                              scenarios[[i]])
  
 
  }

df <- do.call(rbind, tg_data) %>% 
      rename(trophic_group = indicator)

tg_gam_plots[[i]] <- ggplot(df) +
        geom_line(aes(annual_time_step, predicted)) +
        geom_line(aes(x = annual_time_step, y = positive_trend), 
                  col = "blue", size = 1) +
        geom_line(aes(x = annual_time_step, y = negative_trend), 
                  col = "red", size = 1) +
        geom_point(aes(x = annual_time_step, y = observed),
                                        alpha = 0.1,
                   size = 1) +
        geom_ribbon(aes(x = annual_time_step, 
                        ymin = lower_pred, 
                        ymax = upper_pred),
                                        alpha = 0.3) +
                  labs(x = "Time (years)",
                        y = "Standardized abundance",
                       title = scenarios[[i]]) + 
        geom_vline(xintercept=c(100,200), linetype = "dotted") +
        facet_wrap( ~ trophic_group) +
        plot_theme

ggsave(file.path(manuscript_plots_folder, paste(scenarios[[i]],
                                                "trophic_group_gams.png",
                                                sep = "_")),
       width = 10,
       height = 5,
       units = "cm",
       tg_gam_plots[[i]])

tg_gam_data[[i]] <- df

}

walk(tg_gam_plots, print)

```


# All test gams

```{r all test gams, warnings = FALSE, message = FALSE }

ind_method <- "GCV.Cp"
selected <- 1

all_mods_data <- list()
selected_mods <- list()
selected_mods_data <- list()
robust_trends <- list()
deviance_explained <- list()
plots <- list()

for ( i in seq_along(scenario_indicator_single)) {

#scenario <- scenario_indicator_single[[i]]$scenario[1]
scenario <- scenarios_title_2[[i]]
indicator <- scenario_indicator_single[[i]]$indicator[1]

indicator <- str_replace(indicator, "/", "_")

kvals <- c(10,25,50)

m <- gam(indicator_score ~ s(annual_time_step, k = kvals[1]),
         select = TRUE,
         method = ind_method,
         data = scenario_indicator_single[[i]])

m1 <- gam(indicator_score ~ s(annual_time_step, k = kvals[[2]]),
          select = TRUE,
          method = ind_method,
          data = scenario_indicator_single[[i]])

m2 <- gam(indicator_score ~ s(annual_time_step, k = kvals[[3]]),
          select = TRUE,
          method = ind_method,
          data = scenario_indicator_single[[i]])

indicator_mods <- list(m, m1, m2)

# Extract observed, predicted, derivatives and plot for each test gam

test_gam_data <- list()
test_gam_plots <- list()
residual_plots <- list()

for (j in seq_along(indicator_mods)) {
  
# plot.gam(indicator_mods[[j]], residuals = TRUE)

test_gam_data[[j]] <- get_test_gam_data(scenario_indicator_single[[i]],
                               indicator_mods[[j]], scenario)

test_gam_plots[[j]] <- plot_test_gam(test_gam_data[[j]])

}

all_mods_data[[i]] <- test_gam_data

plots[[i]] <- plot_grid(test_gam_plots[[1]],
                        test_gam_plots[[2]],
                        test_gam_plots[[3]],
                        nrow = 2, align = "v")

print(plots[[i]])

ggsave(file.path(supporting_info_plots_folder, paste(scenario, indicator,
                                                "test_gams.png",
                                                sep = "_")),
       width = t_width,
       height = t_height,
       units = "cm",
       plots[[i]])

robust_trends[[i]] <- compare_trends(test_gam_data)

selected_mods[[i]] <- indicator_mods[[selected]]
selected_mods_data[[i]] <- test_gam_data[[selected]]

deviance_explained[[i]] <- round(summary.gam(selected_mods[[i]])$dev.expl, 2)

}

```

# All bootstrapped GAMS

```{r model baseline lpi, warnings = FALSE }

rm(bootstrapped_plots)

bootstrapped_data <- list()
bootstrapped_plots <- list()

for (i in seq_along(selected_mods)) {
  
scenario <- scenario_indicator_single[[i]]$scenario[1]
indicator <- scenario_indicator_single[[i]]$indicator[1]
indicator <- str_replace(indicator, "/", "_")

bootstrapped_data[[i]] <- bootstrap_selected_model(scenario_indicator_single[[i]],
                                 selected_mods[[i]], 
                                 selected_mods_data[[i]], boots) %>% 
          merge(robust_trends[[i]], by = "annual_time_step", all = TRUE) %>% 
          mutate(robust_positive_trend = ifelse(positive_across_all_models == 3,
                                                predicted,NA)) %>% 
          mutate(robust_negative_trend = ifelse(negative_across_all_models == 3,
                                                predicted,NA))

if (indicator == "RLI") {
  
  lims <- c(0.85, 1.00)
  
} else if (indicator == "LPI") {
  
  lims <- c(0.75, 1.15)
}
# hamin <- min(bootstrapped_data[[i]]$predicted_upper) - 0.2
# hamax <- max(bootstrapped_data[[i]]$predicted_lower) + 0.2
# lims <- c(hamin,hamax)


bootstrapped_plots[[i]] <- plot_bootstrapped_model(bootstrapped_data[[i]],
                                                   lims)

print("plot function")
print(i)

write.csv(bootstrapped_data[[i]], file.path(analysis_outputs_folder,
                                            paste(scenario, indicator,
                                                "bootstrapped_trends.csv",
                                                sep = "_")))

print("save csv")
print(i)

ggsave(file.path(manuscript_plots_folder, paste(scenario, indicator,
                                                "bt.png",
                                                sep = "_")),
       width = 10,
       height = 5,
       units = "cm",
       bootstrapped_plots[[i]])


bootstrapped_plots[[i]] <- bootstrapped_plots[[i]] +
                            labs(title = scenario)

print("add title")
print(i)


}

walk(bootstrapped_plots, print)

```

# Summarise trends

```{r summarise trends}

trends <- list()

for (i in seq_along(all_mods_data)) {

  df <- do.call(rbind, all_mods_data[[i]])
 
  scen <- scenarios_title_2[i]
  scen
  # Get the years at which a robust trend is observed
  
  yrs <- robust_trends[[i]] %>% 
       mutate(robust = ifelse(negative_across_all_models == 3,
                              TRUE,
              ifelse(positive_across_all_models == 3, TRUE, FALSE)),
              direction = ifelse(negative_across_all_models == 3,
                              "negative",
              ifelse(positive_across_all_models == 3, "positive", NA))) %>% 
       dplyr::select(annual_time_step, robust, direction) %>% 
          mutate(impact = ifelse(annual_time_step >= 95 &
               annual_time_step <= 105, "Impact start",
               ifelse(annual_time_step >= 195 &
               annual_time_step <= 205, "Impact stop", NA))) %>% 
      filter(!is.na(impact)) %>% 
      dplyr::select(-impact)
  
  
  trend <- df %>% 
          mutate(impact = ifelse(annual_time_step >= 95 &
               annual_time_step <= 105, "Impact start",
               ifelse(annual_time_step >= 195 &
               annual_time_step <= 205, "Impact stop", NA))) %>% 
          filter(impact =="Impact start"|
                 impact == "Impact stop") %>%
          filter(kvalue == 10) %>% 
          dplyr::select(annual_time_step, indicator, scenario, predicted,
                        first_derivative, first_significant, impact) %>% 
          merge(yrs, by = "annual_time_step", all = TRUE) %>% 
          mutate(robust_trend = ifelse(is.na(robust), NA ,
                                       first_derivative),
                 scenario2 = scen) %>% 
          group_by(impact) %>% 
          mutate(ave_trend = mean(robust_trend, na.rm = TRUE)) %>% #Get the average trend 
          dplyr::select(impact, indicator, scenario, scenario2, ave_trend) %>% 
          distinct(.) %>% 
          mutate(ave_trend = ifelse(is.nan(ave_trend), 0, ave_trend))
  
  scenario_fac <- factor(trend$scenario2,
      levels = c("Baseline", "Harvesting primary producers",
                 "Harvesting herbivores", "Harvesting carnivores"))

 trends[[i]] <- cbind(trend,
  scenario_fac = scenario_fac)
  
}

# See all trends
all_robust <- list()

for (i in seq_along(robust_trends)) {
  
  all_robust[[i]] <- robust_trends[[i]] %>% 
                     mutate(id = names(scenario_indicator_single[i]))
}

all_robust_df <- do.call(rbind, all_robust)

```

# Trend heatmap

```{r plot trends}

trend_table <- do.call(rbind, trends) %>% 
               mutate(ave_trend = round(ave_trend, 3)) %>% 
               filter(scenario != "Baseline")

trend_table_wide <- trend_table %>%
                dplyr::select(scenario, indicator, impact, ave_trend) %>% 
               pivot_wider(names_from = c(scenario, impact),
                           values_from = ave_trend)

write.csv(trend_table_wide, file.path(manuscript_plots_folder, 
                   "trend_table.csv"))

plot_data <- trend_table %>% 
            mutate(label = paste(scenario, impact))


heatmap <- ggplot(plot_data, aes(x = impact, y = indicator, 
                                 fill = ave_trend)) +
  geom_tile(color = "white", height = 1.0, width = 1.0, alpha = 0.75) +
  coord_equal() +
  geom_text(aes(label = round(ave_trend, 3)), size = 4) +
  scale_fill_gradient2(
    low = neg_col, mid = 'white', high = pos_col,
    midpoint = 0, guide = 'colourbar', aesthetics = 'fill'
  ) +
  theme(axis.text.x = element_text(size=8, angle = 45, vjust = 0.5, hjust = 1),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none") +
  facet_grid(~ scenario_fac) 

heatmap

ggsave(file.path(manuscript_plots_folder, "results_heatmap.png"),
       width = 18,
       height = 10,
       units = "cm",
       heatmap)


```

# Make species generation length table

```{r match gen lengths}

species_table <- example_species %>% 
     dplyr::select(group_id, common_name, accepted_name, matched) %>% 
     merge(estimated_gen_lengths[c("functional_spp_id", "GL_FIN")], 
           by.x = "group_id", by.y = "functional_spp_id", all = TRUE) %>%
  merge(groups[c("group_id", "functional_group_name", "mass_upper")], 
           by = "group_id") %>%
     dplyr::select(group_id, common_name, accepted_name, GL_FIN, mass_upper,
                   functional_group_name, matched) %>% 
     mutate(gl_method = ifelse(matched == "model spp matches real spp",
                               "mean observed",
                               ifelse(is.na(matched),
                               "mean observed","estimated")),
            upper_mass_kg = mass_upper/1000) %>% 
     filter(matched == "model spp matches real spp" |
              is.na(matched)) %>% 
     rename(functional_spp_id = group_id,
            generation_length_yrs = GL_FIN) %>% 
     mutate(gl_method = ifelse(is.na(gl_method), "estimated",
                               gl_method),
            generation_length_yrs = abs(as.numeric(generation_length_yrs))) %>% 
     dplyr::select(-mass_upper, -matched)
     

write.csv(species_table, file.path(supporting_info_plots_folder, 
                   "species_gl_table.csv"))

```


