---
title: "Analyse terrestrial indicators"
author: "Simone Stevenson"
date: "20/09/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}

# https://bookdown.org/yihui/rmarkdown/r-code.html

knitr::opts_chunk$set(echo = FALSE, message = FALSE,
  warnings = FALSE, error = FALSE)
```

Directory path to git repo

Simone's deakin laptop

cd "C:\\Users\\ssteven\\OneDrive - Deakin University\\Deakin\\Chapter_3_indicator_testing\\madingley_terrestrial_indicators"

Data structure

Input data is structured hierarchically as follows:
- Location (1)
-- Scenarios (3)
--- Replicates (25)

Output indicator data is calculated at the same level, so each indicator should
have values for:
- Location (1)
-- Scenarios (3)
--- Replicates (25)

# Possible useful ref?
https://www.frontiersin.org/articles/10.3389/fevo.2018.00149/full

```{r libraries}

## Data wrangling
library(tidyverse)
library(tidylog)
library(zoo)

## Analysis
library(mgcv)
library(nlme)
library(MASS)
library(datawizard)
#devtools::install_github("saskiaotto/INDperform")
library(INDperform)

## Viz
library(ggpubr)
library(cowplot)
library(gridExtra)
library(gratia)

```
# Functions

```{r functions, echo=FALSE, eval=FALSE}

# Taken from https://gist.github.com/gavinsimpson/e73f011fdaaab4bb5a30

Deriv <- function(mod, n = 200, eps = 1e-7, newdata, term) {
    if(inherits(mod, "gamm"))
        mod <- mod$gam
    m.terms <- attr(terms(mod), "term.labels")
    if(missing(newdata)) {
        newD <- sapply(model.frame(mod)[, m.terms, drop = FALSE],
                       function(x) seq(min(x), max(x), length = n))
        names(newD) <- m.terms
    } else {
        newD <- newdata
    }
    newDF <- data.frame(newD) ## needs to be a data frame for predict
    X0 <- predict(mod, newDF, type = "lpmatrix")
    newDF <- newDF + eps
    X1 <- predict(mod, newDF, type = "lpmatrix")
    Xp <- (X1 - X0) / eps
    Xp.r <- NROW(Xp)
    Xp.c <- NCOL(Xp)
    ## dims of bs
    bs.dims <- sapply(mod$smooth, "[[", "bs.dim") - 1
    ## number of smooth terms
    t.labs <- attr(mod$terms, "term.labels")
    ## match the term with the the terms in the model
    if(!missing(term)) {
        want <- grep(term, t.labs)
        if(!identical(length(want), length(term)))
            stop("One or more 'term's not found in model!")
        t.labs <- t.labs[want]
    }
    nt <- length(t.labs)
    ## list to hold the derivatives
    lD <- vector(mode = "list", length = nt)
    names(lD) <- t.labs
    for(i in seq_len(nt)) {
        Xi <- Xp * 0
        want <- grep(t.labs[i], colnames(X1))
        Xi[, want] <- Xp[, want]
        df <- Xi %*% coef(mod)
        df.sd <- rowSums(Xi %*% mod$Vp * Xi)^.5
        lD[[i]] <- list(deriv = df, se.deriv = df.sd)
    }
    class(lD) <- "Deriv"
    lD$gamModel <- mod
    lD$eps <- eps
    lD$eval <- newD - eps
    lD ##return
}

confint.Deriv <- function(object, term, alpha = 0.05, ...) {
    l <- length(object) - 3
    term.labs <- names(object[seq_len(l)])
    if(missing(term)) {
        term <- term.labs
    } else { ## how many attempts to get this right!?!?
        ##term <- match(term, term.labs)
        ##term <- term[match(term, term.labs)]
        term <- term.labs[match(term, term.labs)]
    }
    if(any(miss <- is.na(term)))
        stop(paste("'term'", term[miss], "not a valid model term."))
    res <- vector(mode = "list", length = length(term))
    names(res) <- term
    residual.df <- df.residual(object$gamModel)
    tVal <- qt(1 - (alpha/2), residual.df)
    ##for(i in term.labs[term]) {
    for(i in term) {
        upr <- object[[i]]$deriv + tVal * object[[i]]$se.deriv
        lwr <- object[[i]]$deriv - tVal * object[[i]]$se.deriv
        res[[i]] <- list(upper = drop(upr), lower = drop(lwr))
    }
    res$alpha = alpha
    res
}

signifD <- function(x, d, upper, lower, eval = 0) {
    miss <- upper > eval & lower < eval
    incr <- decr <- x
    want <- d > eval
    incr[!want | miss] <- NA
    want <- d < eval
    decr[!want | miss] <- NA
    list(incr = incr, decr = decr)
}

plot.Deriv <- function(x, alpha = 0.05, polygon = TRUE,
                       sizer = FALSE, term,
                       eval = 0, lwd = 3,
                       col = "lightgrey", border = col,
                       ylab, xlab, main, ...) {
    l <- length(x) - 3
    ## get terms and check specified (if any) are in model
    term.labs <- names(x[seq_len(l)])
    if(missing(term)) {
        term <- term.labs
    } else {
        term <- term.labs[match(term, term.labs)]
    }
    if(any(miss <- is.na(term)))
        stop(paste("'term'", term[miss], "not a valid model term."))
    if(all(miss))
        stop("All terms in 'term' not found in model.")
    l <- sum(!miss)
    nplt <- n2mfrow(l)
    tVal <- qt(1 - (alpha/2), df.residual(x$gamModel))
    if(missing(ylab))
        ylab <- expression(italic(hat(f)*"'"*(x)))
    if(missing(xlab)) {
        xlab <- attr(terms(x$gamModel), "term.labels")
        names(xlab) <- xlab
    }
    if (missing(main)) {
        main <- term
        names(main) <- term
    }
    ## compute confidence interval
    CI <- confint(x, term = term)
    ## plots
    layout(matrix(seq_len(l), nrow = nplt[1], ncol = nplt[2]))
    for(i in term) {
        upr <- CI[[i]]$upper
        lwr <- CI[[i]]$lower
        ylim <- range(upr, lwr)
        plot(x$eval[,i], x[[i]]$deriv, type = "n",
             ylim = ylim, ylab = ylab, xlab = xlab[i], main = main[i], ...)
        if(isTRUE(polygon)) {
            polygon(c(x$eval[,i], rev(x$eval[,i])),
                    c(upr, rev(lwr)), col = col, border = border)
        } else {
            lines(x$eval[,i], upr, lty = "dashed")
            lines(x$eval[,i], lwr, lty = "dashed")
        }
        abline(h = 0, ...)
        if(isTRUE(sizer)) {
            lines(x$eval[,i], x[[i]]$deriv, lwd = 1)
            S <- signifD(x[[i]]$deriv, x[[i]]$deriv, upr, lwr,
                         eval = eval)
            lines(x$eval[,i], S$incr, lwd = lwd, col = "blue")
            lines(x$eval[,i], S$decr, lwd = lwd, col = "red")
        } else {
            lines(x$eval[,i], x[[i]]$deriv, lwd = 2)
        }
    }
    layout(1)
    invisible(x)
}

# Using Gist from https://fromthebottomoftheheap.net/2014/05/15/identifying-periods-of-change-with-gams/

#' get_derivs is a function to calculate the first derivatives of the predicted indicator values

#' @param mod - gamm object
#' @param data - the input pressure response time step data for the model
#' @param length - double - number of time steps you want to output
#' @param term_string - string, name of model input variable you want to predict against
#' @return a list with a ggplot of first derivatives and significant trends,
#' and output data including observed, predicted, derivatives and confidence intervals

get_derivs <- function(mod, data, length, term_string) {

scenario <- data$scenario[1]
indicator <- data$indicator[1]

want <- seq(1, nrow(data), length.out = length)

pdat <- with(data,
             data.frame(annual_time_step = annual_time_step[want]))

# p2 <- predict.gam(mod$gam, newdata = pdat, type = "terms", se.fit = TRUE, response = TRUE)     pdat <- transform(pdat, p2 = p2$fit[,1], se2 = p2$se.fit[,1])

p2 <- predict.gam(mod$gam, newdata = pdat, se.fit = TRUE, response = TRUE)
pdat <- cbind(pdat, p2 = p2$fit, se2 = p2$se.fit)

df.res <- df.residual(mod$gam)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
pdat <- transform(pdat,
                  upper = p2 + (crit.t * se2),
                  lower = p2 - (crit.t * se2))

Term <- term_string

m2.d <- Deriv(mod) # Gets first derivative
m2.dci <- confint(m2.d, term = Term)
m2.dsig <- signifD(pdat$p2, d = m2.d[[Term]]$deriv,
                    m2.dci[[Term]]$upper, m2.dci[[Term]]$lower)

ylim <- with(pdat, range(upper, lower, p2))

selected_mod_df <- data %>% 
                   dplyr::select(annual_time_step, indicator_score) %>% 
                   merge(pdat, by = "annual_time_step") %>% 
                   mutate(increasing = m2.dsig$incr,
                          decreasing = m2.dsig$decr)

# Recreate with ggplot

deriv_plot <- ggplot() +
  geom_point(data = selected_mod_df,
             aes(x = annual_time_step, y = indicator_score),
             alpha = 0.3) +
  geom_line(aes(x = selected_mod_df$annual_time_step,
                y = selected_mod_df$p2)) +
  geom_line(aes(x = selected_mod_df$annual_time_step, 
                y = selected_mod_df$increasing), col = "blue", size = 2) +
  geom_line(aes(x = selected_mod_df$annual_time_step, 
                y = selected_mod_df$decreasing), col = "red", size = 2) +
  labs(title = paste(scenario,
                     indicator, sep = " "),
       ylab = indicator)

return(list(selected_mod_df, deriv_plot))

}


```

```{r template chunk }

```

```{r data, results=FALSE }

# Set up paths ----

location <- 'Serengeti'

indicators_project <- "N:/Quantitative-Ecology/Indicators-Project"

# Analysis inputs are the outputs of 2_calculate_madingley_indicators.R

analysis_inputs <- "N:/Quantitative-Ecology/Indicators-Project/Serengeti/Outputs_from_indicator_code/Indicator_outputs/general/"

# Inputs ----

# Specify the date of inputs you want to use

input_date <- "2021-09-30"

# Get date to label outputs

output_date <- Sys.Date() 

scenarios_title <- list("Baseline", "Land use", 
                  "Carnivore harvesting", 
                  "Herbivore harvesting")

disturbance_string <- c("pre-disturbance", "disturbance", "post-disturbance")

disturbance_factor <- factor(disturbance_string, ordered = TRUE,
                              levels = c("pre-disturbance", 
                                         "disturbance", 
                                         "post-disturbance"))

# Set up output folders

## Include a folder to store the version of inputs used to get the outputs

analysis_inputs_folder <- file.path(indicators_project,  
                           "/Serengeti/Outputs_from_analysis_code/Analysis_inputs",
                           output_date)

if( !dir.exists( file.path(analysis_inputs_folder) ) ) {
  dir.create( file.path(analysis_inputs_folder), recursive = TRUE )
  
}

analysis_outputs_folder <- file.path(indicators_project, 
                                     "/Serengeti/Outputs_from_analysis_code/Analysis_outputs",
                                     output_date)

if( !dir.exists( file.path(analysis_outputs_folder) ) ) {
  dir.create( file.path(analysis_outputs_folder), recursive = TRUE )
  
}

analysis_plots_folder <- file.path(indicators_project, 
                                     "/Serengeti/Outputs_from_analysis_code/Analysis_plots_folder",
                                   output_date)

if( !dir.exists( file.path(analysis_plots_folder) ) ) {
  dir.create( file.path(analysis_plots_folder), recursive = TRUE )
  
}

# Load indicator > scenario level data ----

indicators_all_df <- readRDS(file.path(analysis_inputs, input_date, "all_indicators_output_dataframe.rds"))

indicators_all_list <- flatten(readRDS(file.path(analysis_inputs,input_date, "all_indicators_output_list.rds")))

# Get list of indicators

indicators <- unique(indicators_all_df$indicator)

# Get list of scenarios

scenarios <- unique(indicators_all_df$scenario)

# Save a copy of the inputs used to create outputs

write.csv(indicators_all_df, file.path(analysis_inputs_folder,
                                       paste(output_date, "input_data.csv",
                                             sep = "_")))
# Load red list data

scenario_redlist_data_sampled <- readRDS(file.path(analysis_inputs, input_date, "scenario_redlist_data_annual_7.rds"))
```

```{r prep data, results = FALSE}
# Standardize & difference the data as per Bestelmeyer 2011

indicators_all_df <- indicators_all_df %>% 
                     group_by(indicator, scenario) %>% 
  filter(indicator == "RLI annual"|
         indicator == "LPI"|
         indicator == "total abundance harvested") %>% 
                     mutate(indicator_score_std = standardize(indicator_score),
                            indicator_score_diff = indicator_score_std - 
                             lag(indicator_score_std, default = 0)) %>% 
                     mutate(scenario_indicator = paste(scenario, indicator, sep = "_"),
                            variance = rollapply(indicator_score_diff,
                               10,
                               var,
                               na.rm = TRUE,
                               partial = TRUE,
                               align = "left"),
                            disturbance = as.integer(ifelse(annual_time_step > 99 &
                                                 annual_time_step < 201,
                                                 1, 0)),
                            disturbance_factor = as.factor(ifelse(disturbance == 1,
                                                 "disturbance", 
                                                 "no disturbance")),
                            years_since_disturbance = ifelse(annual_time_step < 100,
                                                            1, (annual_time_step - 100)),
                            disturbance_phase = as.integer(ifelse(annual_time_step < 100,
                                                                  1,
                                                 ifelse(annual_time_step > 99 &
                                                 annual_time_step < 201,
                                                 2, 3)))) %>%
                     ungroup(.)

# Split into a list of scenarios then indicators

scenario_indicators <- split(indicators_all_df, indicators_all_df$scenario)

# Or vice versa

indicator_scenarios <- split(indicators_all_df, indicators_all_df$indicator)

# Single indicator, single scenario

scenario_indicator_single <- split(indicators_all_df, indicators_all_df$scenario_indicator)

# Make a test df of one scenario, one indicator for building loop content

test_df <- scenario_indicators[[2]] %>% 
           filter(indicator == "LPI")

```

```{r prep gam inputs, results=FALSE }

# * LPI ----
# *** Prep inputs ----

unique(indicators_all_df$indicator)
unique(indicators_all_df$scenario)
ind <- "LPI"
scen <- "100_Land_use"

response <- indicators_all_df %>% 
  filter(indicator == ind) %>% 
  filter(scenario == scen) %>% 
  dplyr::select(annual_time_step, indicator_score)

predictor <- indicators_all_df %>% 
  filter(indicator == "total abundance harvested") %>% 
  filter(scenario == scen) %>% 
  mutate(indicator_score_std = exp(indicator_score_std)) %>% 
  rename(pressure_var_c = indicator_score_std,
         pressure_var_f = disturbance_factor) %>% 
  dplyr::select(annual_time_step, pressure_var_c, pressure_var_f,
                years_since_disturbance, disturbance_phase)


pr_gam_inputs <- response %>% 
  merge(predictor, by = "annual_time_step")



```
# Using MGCV All models

```{r m all, echo = TRUE}

selected_mods <- list()

for(i in seq_along(scenario_indicator_single)) {

print(scenario_indicator_single[[i]]$scenario_indicator[1])
  
selected_mods[[i]] <- gamm(indicator_score ~ s(annual_time_step),
          select = TRUE,
          data = scenario_indicator_single[[i]],
          correlation = corCAR1(form = ~ 1 | annual_time_step))

}

names(selected_mods) <- names(scenario_indicator_single)

gam.check(selected_mods[[1]]$gam)
names(selected_mods)[1] #LPI
gam.check(selected_mods[[2]]$gam)
names(selected_mods)[2] # RLI
gam.check(selected_mods[[3]]$gam) 
names(selected_mods)[3] # baseline abundance, doesn't matter if weird 
gam.check(selected_mods[[4]]$gam)
names(selected_mods)[4] #LPI
gam.check(selected_mods[[5]]$gam)
names(selected_mods)[5] #RLI
gam.check(selected_mods[[6]]$gam) 
names(selected_mods)[6] # total abundance harvested, may not matter either
gam.check(selected_mods[[7]]$gam)
names(selected_mods)[7] #LPI
gam.check(selected_mods[[8]]$gam) 
names(selected_mods)[8] # RLI annual carnivores, IMPORTANT, needs more work
gam.check(selected_mods[[9]]$gam) 
names(selected_mods)[9] # Abundance carnivores, may not matter
gam.check(selected_mods[[10]]$gam) 
names(selected_mods)[10] # LPI herbivores, IMPORTANT, needs more work
gam.check(selected_mods[[11]]$gam)
names(selected_mods)[11] # RLI
gam.check(selected_mods[[12]]$gam) 
names(selected_mods)[12] # Abundance harvested, may not matter

```

# Using INDperform

```{r m all, echo = TRUE}


selected_mods2 <- list()

for(i in seq_along(scenario_indicator_single)) {

print(scenario_indicator_single[[i]]$scenario_indicator[1])
  
ind_trend_inputs <- scenario_indicator_single[[i]] %>%
                    dplyr::select(annual_time_step, indicator_score, indicator) %>% 
                    pivot_wider(names_from = indicator,
                                values_from = indicator_score) %>%
                    arrange(annual_time_step)
  
selected_mods2[[i]] <- model_trend(ind_tbl = ind_trend_inputs[ ,-1],
  time = ind_trend_inputs$annual_time_step, family = Tweedie(p =2))

}

names(selected_mods2) <- names(scenario_indicator_single)

plot_trend(selected_mods2[[1]])
plot_trend(selected_mods2[[2]])
plot_trend(selected_mods2[[3]])
plot_trend(selected_mods2[[4]])
plot_trend(selected_mods2[[5]])
plot_trend(selected_mods2[[6]])
plot_trend(selected_mods2[[7]])
plot_trend(selected_mods2[[8]])
plot_trend(selected_mods2[[9]])
plot_trend(selected_mods2[[10]])
plot_trend(selected_mods2[[11]])
plot_trend(selected_mods2[[12]])

```

```{r breakpoints }

breakpoint_plots <- list()

for ( i in seq_along(scenario_indicator_single)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- scenario_indicator_single[[i]]
  
  scenario <- single_scenario$scenario[1]
  
  indicator <- single_scenario$indicator[1]

  m_binseg <- cpt.mean(log(single_scenario$indicator_score), 
                       penalty = "AIC", method = "BinSeg", Q = 2)
  
  plot(m_binseg, type = "l", xlab = "Index", cpt.width = 4, 
  main = paste(scenario, indicator, sep = " "))
  
  cpt <- c(10, m_binseg@cpts)
  
  # breakpoint_plots[[i]] <- ggplot() +
  #   geom_line(data = single_scenario[[j]],
  #                                aes(x = annual_time_step,
  #                                    y = indicator_score_std)) +
  #   geom_point()

}

breakpoint_plots[[1]]
breakpoint_plots[[2]]
breakpoint_plots[[3]]
breakpoint_plots[[4]]
```


# Model selection so far

```{r model selection 1, echo = TRUE }

anova.lme(m$lme, m1$lme, m2$lme, m3$lme)

selected_mod <- m1

gam.check(selected_mod$gam)

```

# Plot fitted against observed

```{r model selection 1, echo = TRUE }

fitted_observed_plots <- list()

for (i in seq_along(scenario_indicator_single)) {
  
fit_obs_df <- data.frame(annual_time_step = scenario_indicator_single[[i]]$annual_time_step, 
                   fitted = selected_mods[[i]]$gam$fitted.values, 
                   observed = scenario_indicator_single[[i]]$indicator_score)

fitted_observed_plots[[i]] <- ggplot() + 
  geom_line(data = fit_obs_df, aes(annual_time_step, fitted)) + 
  geom_point(data = fit_obs_df, aes(annual_time_step, observed))

}

fitted_observed_plots[[1]]
plot_trend(selected_mods2[[1]])
fitted_observed_plots[[2]]
fitted_observed_plots[[3]]
fitted_observed_plots[[4]]
fitted_observed_plots[[5]]
fitted_observed_plots[[6]]
fitted_observed_plots[[7]]
fitted_observed_plots[[8]]
fitted_observed_plots[[9]]
fitted_observed_plots[[10]]
fitted_observed_plots[[11]]
fitted_observed_plots[[12]]

```

# 1st derivatives

First derivatives show the rate of change in the indicator at a specific time 
point. Values = 0 signify no trend, values > 0 signify a positive trend, and 
values < 0 signify a negative trend.

```{r 1st derivatives, echo = TRUE }

# Using gratia package

obs <- scenario_indicator_single[[i]]$indicator_score

pdat <- data.frame(annual_time_step = seq(1,290,1))

p2 <- predict.gam(selected_mods[[i]]$gam, pdat, 
                  se.fit = TRUE, response = TRUE)

pdat <- cbind(pdat, predicted = p2$fit, se2 = p2$se.fit, obs)

df.res <- df.residual(selected_mods[[i]]$gam)
crit.t <- qt(0.025, df.res, lower.tail = FALSE)
pdat <- transform(pdat,
                  upper_pred = predicted + (crit.t * se2),
                  lower_pred = predicted - (crit.t * se2))

gratia_derivs_1 <- as.data.frame(derivatives(selected_mods[[i]], order = 1, 
                   n = 290, interval = "confidence") ) 

temp <- cbind(pdat, gratia_derivs_1)

indicator <- scenario_indicator_single[[i]]$indicator[1]
scenario <- scenario_indicator_single[[i]]$scenario[1]

derivatives_plot_data <- temp %>% 
                   mutate(significant = ifelse(lower < 0 & upper > 0, FALSE, TRUE),
                          positive_pred = ifelse(significant == TRUE & derivative > 0,
                                            predicted,NA),
                          negative_pred = ifelse(significant == TRUE & derivative < 0,
                                            predicted, NA),
                          positive_der = ifelse(significant == TRUE & derivative > 0,
                                            derivative,NA),
                          negative_der = ifelse(significant == TRUE & derivative < 0,
                                            derivative, NA)) 

ggplot(derivatives_plot_data) +
  geom_ribbon(aes(x = annual_time_step, ymin = lower, ymax = upper),
              alpha = 0.3) +
  geom_line(aes(x = annual_time_step,
                y = derivative)) +
  geom_line(aes(x = annual_time_step,
         y = positive_der), col = "blue")+
  geom_line(aes(x = annual_time_step,
         y = negative_der), col = "red") +
  geom_hline(yintercept = 0, col = "green")



ggplot(data = derivatives_plot_data) +
  geom_point(aes(x = annual_time_step, y = obs), alpha = 0.2) +
  geom_line(aes(x = annual_time_step, y = predicted)) +
  geom_ribbon(aes(x = annual_time_step, ymin = lower_pred, ymax = upper_pred),
              alpha = 0.3) +
  geom_line(aes(x = annual_time_step, y = positive_pred), col = "blue") +
  geom_line(aes(x = annual_time_step, y = negative_pred), col = "red") +
  labs(y = indicator,
       title = scenario) +
  theme_classic()

```

# Graveyard 
```{r graveyard, echo = TRUE }

# Using Jess' method

test_plots <- list()

d <- 2

for (i in seq_along(scenario_indicator_single)) {
  
fit_obs_df <- data.frame(annual_time_step = scenario_indicator_single[[i]]$annual_time_step, 
                   fitted = selected_mods[[i]]$gam$fitted.values, 
                   observed = scenario_indicator_single[[i]]$indicator_score_std)

deriv_func <- splinefun(x = fit_obs_df$annual_time_step, y = fit_obs_df$fitted)
deriv_fitted <- as.data.frame(x = deriv_func(seq(1, 290, 1), deriv = d))

deriv_df <- cbind(ts = fit_obs_df$annual_time_step,d = deriv_fitted,
                  observed = fit_obs_df$observed)

names(deriv_df) <- c("annual_time_step", "deriv", "observed")

test_plots[[i]] <- ggplot() +
                   #geom_point(data = deriv_df,aes(annual_time_step, observed)) +
                   geom_line(data = deriv_df,aes(annual_time_step, deriv))



}

i <- i + 1
test_plots[[i]]





```

# 2nd derivatives

Second derivatives show when the indicator values have changed direction.
"The second derivative of the trend curbe I(t) at time t is a measure of the curvature of I at that time. If the second derivative is greater than zero, the curve is turning upward. If it is less than zero, the curve is turning downward. The magnitude of the second derivative signifies the tightness of the curvature. Values of approx 0 indicate the curve is linear and changing at a steady state. Years in which the second derivative is markedly different from zero are those in which something is happening to alter the rate of population change." (Fewster et al 2000)

```{r derivative 2, echo = TRUE }

deriv_func <- splinefun(x = fit_obs_df$annual_time_step, y = fit_obs_df$fitted)
deriv_fitted <- as.data.frame(x = deriv_func(seq(1, 290, 1), deriv = 2))

deriv_df <- cbind(ts = fit_obs_df$annual_time_step,d = deriv_fitted)

ggplot(deriv_df, aes(ts, `deriv_func(seq(1, 290, 1), deriv = 2)`))+
  geom_line()


gratia_derivs_2 <- derivatives(selected_mods[[i]], order = 2, 
                    n = 290, interval = "confidence")

draw(gratia_derivs_1)
draw(gratia_derivs_2)


```

```{r misc }

m1 <- gamm(response_var ~ s(annual_time_step)+ pressure_var_f, 
          data = pr_gam_inputs,
           correlation = corARMA(form = ~ 1|seasonal_var, p = 1))


intervals(m1$lme, which = "var-cov")$corStruct

AIC(m, m0, m1$lme)

selected_mod <- m1

test <- data.frame(annual_time_step = pr_gam_inputs$annual_time_step, 
                   fitted = selected_mod$gam$fitted.values, 
                   observed = pr_gam_inputs$response_var)

ggplot() + 
  geom_line(data = test, aes(annual_time_step, fitted)) + 
  geom_point(data = test, aes(annual_time_step, observed))


deriv_func <- splinefun(x = test$annual_time_step, y = test$fitted)
deriv_fitted <- as.data.frame(x = deriv_func(seq(1, 290, 1), deriv = 2))

deriv_df <- cbind(ts = test$annual_time_step,d = deriv_fitted)

ggplot(deriv_df, aes(ts, `deriv_func(seq(1, 290, 1), deriv = 2)`))+
  geom_line()

# https://petolau.github.io/Analyzing-double-seasonal-time-series-with-GAM-in-R/
# https://fromthebottomoftheheap.net/2014/05/09/modelling-seasonal-data-with-gam/
# https://asbates.rbind.io/2019/04/19/time-series-with-spline-based-models/
# https://asbates.rbind.io/2019/05/03/gams-for-time-series/ 

fit <- auto.arima(resid(m1$lme, type = "normalized"),
                       stationary = TRUE, seasonal = TRUE)

fit$coef

plot(forecast(fit,h=20))
summary(fit)

plot(pr_gam_inputs$pressure_var_f, resid(m1), xlab = "disturbance",
ylab = "Residuals")

plot(pr_gam_inputs$pressure_var_c, resid(m1), xlab = "disturbance level",
ylab = "Residuals")

plot(pr_gam_inputs$annual_time_step, resid(m1), xlab = "annual time step",
ylab = "Residuals")



selected_mod <- mmmm

gam.check(selected_mod$gam)

E <- residuals(selected_mod, type = "response")
I1 <- !is.na(pr_gam_inputs$response_var)
Efull <- vector(length = length(pr_gam_inputs$response_var))
Efull <- NA
Efull[I1] <- E
acf(Efull, na.action = na.pass,
main = "Auto-correlation plot for residuals")

acf(Efull, plot = FALSE)
pacf(Efull, plot = FALSE)

```


# Model selection

```{r model selection }

#Using ANOVA (as per https://fromthebottomoftheheap.net/2014/05/09/modelling-seasonal-data-with-gam/)

# anova(m1, m2$lme, m3, m4$lme, m5, m6$lme)

## Using AIC
mod_sel_table <- as.data.frame(AIC(m1, m2$lme, m3$lme, m4))
mod_sel_table

# Define selected model

selected_mod <- m4

summary(selected_mod)

plot(selected_mod, residuals = TRUE, pch = 19, cex = 0.75)

gam.check(selected_mod)
```

```{r plot selected mods, eval = FALSE}

summary(pr_gam_inputs)

pdat <- data.frame(annual_time_step = c(1:300),
                   pressure_var_f = as.factor("disturbance"))

head(pdat)

p <- predict(selected_mod, newdata = pdat, type = "response")
p

pdat <- cbind(pdat,p)
lines(p ~ annual_time_step, data = pdat, col = "pink")
# lines(p1 ~ annual_time_step, data = pdat, col = "red")
# lines(p2 ~ annual_time_step, data = pdat, col = "blue")
legend("topleft",
       legend = c("Uncorrelated Errors","AR(1) Errors"),
       bty = "n", col = c("red","blue"), lty = 1)

# *** Plot the derivatives and periods of change ----

m2.d <- Deriv(selected_mod$terms, n = 300)
plot(m2.d, sizer = TRUE, alpha = 0.01)

# Add periods of change to time series

plot(LPI ~ annual_time_step, data = pr_gam_inputs, 
     type = "p")
lines(p ~ annual_time_step, data = pdat)
CI <- confint(m2.d, alpha = 0.01)
S <- signifD(p, m2.d$annual_time_step$deriv, 
             CI$annual_time_step$upper, 
             CI$annual_time_step$lower,
             eval = 0)
lines(S$incr ~ annual_time_step, data = pdat, lwd = 3, col = "blue")
lines(S$decr ~ annual_time_step, data = pdat, lwd = 3, col = "red")
# Recreate with ggplot

deriv_plot <- ggplot() +
  geom_point(data = gam_inputs,
             aes(x = annual_time_step, y = indicator_score),
             alpha = 0.3) +
  geom_line(aes(x = gam_inputs$annual_time_step,
                y = p2)) +
  geom_line(aes(x = gam_inputs$annual_time_step, 
                y = S$incr), col = "blue", size = 2) +
  geom_line(aes(x = gam_inputs$annual_time_step, 
                y = S$decr), col = "red", size = 2) +
  labs(title = paste(gam_inputs$scenario[1],
                     gam_inputs$indicator[1], sep = " "))

deriv_plot

ggsave(file.path(analysis_plots_folder,
                 paste(gam_inputs$indicator[1],"_", gam_inputs$scenario[1], 
                       "derivative_plot.png", sep = "")),
       deriv_plot,  device = "png")

```
