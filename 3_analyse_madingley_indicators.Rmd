---
title: "Analyse terrestrial indicators"
author: "Simone Stevenson"
date: "20/09/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}

# https://bookdown.org/yihui/rmarkdown/r-code.html

knitr::opts_chunk$set(echo = FALSE, message = FALSE,
  warnings = FALSE, error = FALSE)
```

Directory path to git repo

Simone's deakin laptop

cd "C:\\Users\\ssteven\\OneDrive - Deakin University\\Deakin\\Chapter_3_indicator_testing\\madingley_terrestrial_indicators"

Data structure

Input data is structured hierarchically as follows:
- Location (1)
-- Scenarios (3)
--- Replicates (25)

Output indicator data is calculated at the same level, so each indicator should
have values for:
- Location (1)
-- Scenarios (3)
--- Replicates (25)

#' TODO: Add impact lines to everything
#' TODO: Move the important groups code to the indicator calculation script

```{r libraries}

## Data wrangling
library(tidyverse)
library(tidylog)

## Analysis
library(mgcv)
library(nlme)
library(changepoint)
library(MASS)
library(strucchange)
library(datawizard)
library(arules)

## Viz
library(ggpubr)
library(cowplot)
library(gridExtra)
library(scales)

```

```{r bin_rates_of_change, echo=FALSE}

#' Description

#' @param data a data frame with columns 'group id', 'annual_time_step', 'ave_abundance'
#' @param set_breals a vector of numbers specifying the binds for rates of change
#' @return a dataframe of the identity and proportion of species in each rate of change bin
#' per timestep. NOTE - this data needs the species identity removed to plot
#' overall rates of change

#data <- scenario_redlist_data_sampled[[2]]

bin_rates_of_change <- function(data, set_breaks){

  require(arules)
  
    filtered_inputs <- data %>%
    # Group by virtual species (vs)
    group_by(group_id) %>% 
    # Remove vs that have no individuals at any timestep
    filter(!all(ave_abundance == 0)) %>% 
    # Save a copy of original abundance values
    # rename(abundance_original = abundance) %>%
    # Identify rows where abundance == 0, and change all subsequent years to 0 too
    # mutate(abundance = maintain_0_abundance(abundance_original)) 
    mutate(abundance = ave_abundance) %>% 
    dplyr::select(-ave_abundance)
  
  head(filtered_inputs)
  
  # Calculate rates of change as if for the LPI
  ## Based on McRae, L., Loh. J., Bubb, P.J., Baillie, J.E.M., Kapos, V.,
  ## and Collen, B. 2008. The Living Planet Index - Guidance for
  ## National and Regional Use. UNEP-WCMC, Cambridge, UK.
  
  lpi_inputs <- filtered_inputs %>%
    # Calculate 1% of the mean population over time for each group
    group_by(group_id) %>%
    # Add 1% of the species mean abundance across all timesteps
    # so we can take the log in the next step
    mutate(abundance_adjusted = abundance +
             (mean(abundance, na.rm = TRUE)*0.01)) %>%
    # Calculate the rate of change since the previous year (dt)
    # (equation 1 in Mcrae et al 2008)
    mutate(current_abundance = abundance_adjusted, #abundance at current timestep
           previous_abundance = lag(abundance_adjusted, 1)) %>%  #abundance at previous timestep
    mutate(dt = log10(current_abundance/previous_abundance)) %>% # rate of change
    ungroup(.) 
  
    # Look at the breakdown of change rates in yr 80
  # y80 <- lpi_inputs %>% 
  #        filter(annual_time_step == 80)
  # 
  # hist(y80$dt, 30)
  # quantile(y80$dt)
  
  dt_bins_1 <- lpi_inputs %>% 
    group_by(annual_time_step) %>% 
    mutate(dt_bins = discretize(dt, "fixed", breaks = set_breaks, 
                                ordered_result = TRUE)) %>% 
    filter(!is.na(dt_bins)) %>%
    group_by(annual_time_step) %>% 
    mutate(num_groups = n_distinct(group_id)) %>% 
    ungroup(.) %>% 
    group_by(annual_time_step, dt_bins) %>% 
    mutate(group_id = group_id,
           ave_abundance = abundance,
           functional_group_name = functional_group_name,
           num_in_bin = n_distinct(group_id),
           prop_declining = num_in_bin/num_groups) %>% 
    distinct(.) %>% 
    dplyr::select(annual_time_step, dt_bins, num_in_bin, num_groups,
                  prop_declining, ave_abundance, functional_group_name) %>% 
    arrange(annual_time_step, dt_bins) %>% 
    distinct(.)
  
  # Add an ordered factor for plotting
  
  dt_bins_rev <- factor(dt_bins_1$dt_bins,
      levels = c( "[-3,-0.0894)",
                  "[-0.0894,-0.0166)","[-0.0166,0)",
                  "[0,0.0147)","[0.0147,0.307)", "[0.307,3]"))
  
  dt_bins <- cbind(dt_bins_1,
  dt_bins_rev = dt_bins_rev)
                       
return(dt_bins)
  
}
```

```{r ggplot theme}

plot_theme <- theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_rect(fill = "grey80"),
          legend.position = "bottom",
         legend.key.size = unit(0.25, 'cm'),
         plot.title = element_text(size = 10, face = "bold"),
         legend.title=element_text(size=6), 
         legend.text=element_text(size=5),
          axis.title.x = element_text(size=8),
          axis.title.y = element_text(size=8),
          axis.text.x = element_text(size=6),
          axis.text.y = element_text(size=6),
          axis.ticks.x = element_blank(), 
          axis.ticks.y = element_blank())

```

```{r colour palettes, eval=FALSE}

# Check for CB compatibility here: https://www.color-blindness.com/coblis-color-blindness-simulator/

show_col(viridis_pal()(20))
show_col(viridis_pal(option = "plasma")(20))
show_col(viridis_pal(option = "magma")(20))
show_col(viridis_pal(option = "inferno")(20))
show_col(viridis_pal(option = "mako")(20))
show_col(viridis_pal(option = "cividis")(20))
show_col(viridis_pal(option = "rocket")(20))
show_col(viridis_pal(option = "turbo")(20))

```

```{r template chunk }

```

```{r data }

# Set up paths ----

location <- 'Serengeti'

indicators_project <- "N:/Quantitative-Ecology/Indicators-Project"

# Analysis inputs are the outputs of 2_calculate_madingley_indicators.R

analysis_inputs <- "N:/Quantitative-Ecology/Indicators-Project/Serengeti/Outputs_from_indicator_code/Indicator_outputs/general/"

# Inputs ----

# Specify the date of inputs you want to use

input_date <- "2021-09-30"

# Get date to label outputs

output_date <- Sys.Date() 

scenarios_title <- list("Baseline", "Land use", 
                  "Carnivore harvesting", 
                  "Herbivore harvesting")

disturbance_string <- c("pre-disturbance", "disturbance", "post-disturbance")

disturbance_factor <- factor(disturbance_string, ordered = TRUE,
                              levels = c("pre-disturbance", 
                                         "disturbance", 
                                         "post-disturbance"))

# Set up output folders

## Include a folder to store the version of inputs used to get the outputs

analysis_inputs_folder <- file.path(indicators_project,  
                           "/Serengeti/Outputs_from_analysis_code/Analysis_inputs",
                           output_date)

if( !dir.exists( file.path(analysis_inputs_folder) ) ) {
  dir.create( file.path(analysis_inputs_folder), recursive = TRUE )
  
}

analysis_outputs_folder <- file.path(indicators_project, 
                                     "/Serengeti/Outputs_from_analysis_code/Analysis_outputs",
                                     output_date)

if( !dir.exists( file.path(analysis_outputs_folder) ) ) {
  dir.create( file.path(analysis_outputs_folder), recursive = TRUE )
  
}

# analysis_plots_folder <- file.path(indicators_project, 
#                                      "/Serengeti/Outputs_from_analysis_code/Analysis_plots_folder",
#                                    output_date)
# 
# if( !dir.exists( file.path(analysis_plots_folder) ) ) {
#   dir.create( file.path(analysis_plots_folder), recursive = TRUE )
#   
# }

manuscript_plots_folder <- file.path(indicators_project, 
                                     "/Serengeti/Outputs_from_analysis_code/manuscript_plots_folder",
                                   output_date)

if( !dir.exists( file.path(manuscript_plots_folder) ) ) {
  dir.create( file.path(manuscript_plots_folder), recursive = TRUE )
  
}

supporting_info_plots_folder <- file.path(indicators_project, 
                                     "/Serengeti/Outputs_from_analysis_code/supporting_info_plots_folder",
                                   output_date)

if( !dir.exists( file.path(supporting_info_plots_folder) ) ) {
  dir.create( file.path(supporting_info_plots_folder), recursive = TRUE )
  
}

# Load indicator > scenario level data ----

indicators_all_df <- readRDS(file.path(analysis_inputs, input_date, "all_indicators_output_dataframe.rds"))

indicators_all_list <- flatten(readRDS(file.path(analysis_inputs,input_date, "all_indicators_output_list.rds")))


# Get list of indicators

indicators <- unique(indicators_all_df$indicator)

# Get list of scenarios

scenarios <- unique(indicators_all_df$scenario)

# Save a copy of the inputs used to create outputs

write.csv(indicators_all_df, file.path(analysis_inputs_folder,
                                       paste(output_date, "input_data.csv",
                                             sep = "_")))
# disable scientific notation

options(scipen = 999)

# Get group information

groups <- read.csv(file.path(analysis_inputs, input_date, "groups.csv"))

# Load red list data

scenario_redlist_data_sampled_raw <- readRDS(file.path(analysis_inputs, input_date, "scenario_redlist_data_annual_7.rds"))

```

```{r prep data}

# Standardize & difference the data as per Bestelmeyer 2011

indicators_all_df <- indicators_all_df %>% 
                     group_by(indicator, scenario) %>% 
  filter(indicator == "RLI annual"|
         indicator == "LPI"|
         indicator == "total abundance harvested") %>% 
                     mutate(indicator_score_std = standardize(indicator_score),
                            indicator_score_diff = indicator_score_std - 
                             lag(indicator_score_std, default = 0)) %>% 
                     mutate(variance = rollapply(indicator_score_diff,
                               10,
                               var,
                               na.rm = TRUE,
                               partial = TRUE,
                               align = "left"),
                            disturbance = as.integer(ifelse(annual_time_step > 99 &
                                                 annual_time_step < 201,
                                                 1, 0)),
                            disturbance_factor = as.factor(ifelse(disturbance == 1,
                                                 "disturbance", 
                                                 "no disturbance")),
                            years_since_disturbance = ifelse(annual_time_step < 100,
                                                            1, (annual_time_step - 100))) %>%
                     ungroup(.)


# Split into a list of scenarios then indicators

scenario_indicators <- split(indicators_all_df, indicators_all_df$scenario)

# Or vice versa

indicator_scenarios <- split(indicators_all_df, indicators_all_df$indicator)

# Single indicator, single scenario

scenario_indicator_single <- split(indicators_all_df,
                                   list(indicators_all_df$scenario,
                                   indicators_all_df$indicator))

# Make a test df of one scenario, one indicator for building loop content

test_df <- scenario_indicators[[2]] %>% 
           filter(indicator == "LPI")

# Add range massbins to the spp data


temp <- groups %>% 
        dplyr::select(group_id, mass_lower, mass_upper) %>% 
        mutate(mass_lower_kg = mass_lower/1000,
               mass_upper_kg = mass_upper/1000,
               mass_range_kg = paste(mass_lower_kg, mass_upper_kg, sep = "-"))

scenario_redlist_data_sampled <- list()

for(i in seq_along(scenario_redlist_data_sampled_raw)) {
  

scenario_redlist_data_sampled[[i]] <- scenario_redlist_data_sampled_raw[[i]] %>% 
         merge(temp[c("group_id", "mass_range_kg")], by = "group_id")

}

rm(temp, scenario_redlist_data_sampled_raw)

```

# Visualise smoothed time series using loess at 25 and 50% smoothing spans

```{r visualise, warning=FALSE, message = FALSE, error=FALSE}

# Visualise smoothed time series using loess as in Bestelmeyer 2011

# http://r-statistics.co/Loess-Regression-With-R.html

loess_plots_1 <- list()

for ( i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicators <- names(single_scenario)
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
    
  # Get the scenario
  
  indicator <- single_scenario[[j]]$indicator[1]


loessMod10 <- loess(indicator_score_std ~ annual_time_step, 
                    data = single_scenario[[j]], span=0.10) # 10% smoothing span
loessMod25 <- loess(indicator_score_std ~ annual_time_step, 
                    data = single_scenario[[j]], span=0.25) # 25% smoothing span
loessMod50 <- loess(indicator_score_std ~ annual_time_step, 
                    data = single_scenario[[j]], span=0.50) # 50% smoothing span

# get smoothed output
smoothed10 <- as.data.frame(cbind(annual_time_step = single_scenario[[j]]$annual_time_step, 
                            indicator_score_loess = predict(loessMod10))) 

smoothed25 <-  as.data.frame(cbind(annual_time_step = single_scenario[[j]]$annual_time_step, 
                            indicator_score_loess = predict(loessMod25)))

smoothed50 <-  as.data.frame(cbind(annual_time_step = single_scenario[[j]]$annual_time_step, 
                            indicator_score_loess = predict(loessMod50)))

indicator_plots[[j]] <- ggplot() +
  geom_point(data = single_scenario[[j]], aes(annual_time_step, 
                                              indicator_score_std),
             alpha = 0.2) +
  # geom_line(data = smoothed10, aes(x = annual_time_step, 
  #                                  y = indicator_score_loess), col = "red") + 
  theme(axis.text = element_text(size = 2),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6)) +
  geom_line(data = smoothed25, aes(annual_time_step, indicator_score_loess), col = "green") +
  geom_line(data = smoothed50, aes(annual_time_step, indicator_score_loess), col = "blue") +
  labs(title = indicator,
       x = "Annual time step",
       y = "Indicator") +
  geom_vline(xintercept=c(100,200), linetype="dotted") 

  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  loess_plots_1[[i]] <- plot_grid(title,
                                                     indicator_plots[[1]],
                                                     indicator_plots[[2]],
                                                     indicator_plots[[3]],
                                                     # indicator_plots[[4]],
                                                     # indicator_plots[[5]],
                                                     nrow = 2, align = "v")
rm(indicator_plots, indicator)

}
loess_plots_1[[1]]
loess_plots_1[[2]]
loess_plots_1[[3]]
loess_plots_1[[4]]

```


```{r breakpoints, eval = FALSE }
# https://www.marinedatascience.co/blog/2019/09/28/comparison-of-change-point-detection-methods/

## Using the changepoint package:

# https://kevin-kotze.gitlab.io/tsm/ts-2-tut/

breakpoint_plots <- list()

for ( i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicators <- names(single_scenario)
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
    
  # Get the scenario
  
  indicator <- single_scenario[[j]]$indicator[1]

  m_binseg <- cpt.mean(single_scenario[[j]]$indicator_score_std, 
                       penalty = "BIC", method = "BinSeg", Q = 5)
  
  plot(m_binseg, type = "l", xlab = "Index", cpt.width = 4, 
  main = paste(scenario, indicator, sep = " "))
  
  cpt <- c(10, m_binseg@cpts)
  
  indicator_plots[[j]] <- ggplot() +
    geom_line(data = single_scenario[[j]],
                                 aes(x = annual_time_step,
                                     y = indicator_score_std)) +
    geom_point


  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  breakpoint_plots[[i]] <- plot_grid(title,
                                                     indicator_plots[[1]],
                                                     indicator_plots[[2]],
                                                     indicator_plots[[3]],
                                                     # indicator_plots[[4]],
                                                     # indicator_plots[[5]],
                                                     nrow = 2, align = "v")
rm(indicator_plots, indicator)

}

breakpoint_plots[[1]]
breakpoint_plots[[2]]
breakpoint_plots[[3]]
breakpoint_plots[[4]]



# # Using the strucchange package - think it only identifies one break??
# ## Another tutorial https://datascienceplus.com/structural-changes-in-global-warming/
# 
# 
# head(data)
# 
# i <- i + 1
# data <- indicators_all_df %>% 
#         filter(scenario == "300_Harvesting_herbivores" &
#                indicator == indicators[i]) %>% 
#         mutate(lag_indicator_score_diff = lag(indicator_score_diff, 1))
# 
# data2 <- data[-1,]
# print(data2$indicator[1])
# qlr <- Fstats(lag_indicator_score_diff ~ indicator_score_diff, data = data2)
# breakpoints(qlr)
# summary(qlr)
# sctest(qlr, type = "supF")
# plot(qlr)

```

# Visualise the frequency distribution of the indicator values & abundance of harvested groups

```{r frequency distribution, eval = FALSE }

# Visualise the frequnecy distribution and density of indicators as in Bestelmeyer 2011

distribution_plots_1 <- list()

for (i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
  
  # Get the indicator name
  
  indicator <- single_scenario[[j]]$indicator[1]


indicator_plots[[j]] <- ggplot(data = single_scenario[[j]], 
                               aes(indicator_score_std)) +
  geom_histogram(aes(y = ..density..), colour="black", fill="white") +
  geom_density(alpha = 0.2, fill = "hotpink") + 
  theme(axis.text = element_text(size = 2),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6)) +
  labs(title = indicator,
       x = "Indicator score",
       y = "Density") 

  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  distribution_plots_1[[i]] <- plot_grid(title,
                                         indicator_plots[[1]],
                                         indicator_plots[[2]],
                                         indicator_plots[[3]],
                                         # indicator_plots[[4]],
                                         # indicator_plots[[5]],
                                         nrow = 2, align = "v")
rm(indicator_plots, indicator)

}

distribution_plots_1[[1]]
distribution_plots_1[[2]]
distribution_plots_1[[3]]
distribution_plots_1[[4]]

```

# Indicator distributions coloured by disturbance & non-disturbance time steps

```{r frequency distribution by disturbance }

# Visualise the frequnecy distribution and density of indicators as in Bestelmeyer 2011

distribution_plots_2 <- list()

for (i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
  
  # Get the indicator name
  
  indicator <- single_scenario[[j]]$indicator[1]
  
  
  indicator_plots[[j]] <- ggplot(data = single_scenario[[j]], 
                            aes(indicator_score_std)) +
  geom_histogram(aes(y = ..density.., group = disturbance_factor, 
                     fill = disturbance_factor), colour="black",
                   position = 'identity') +
  geom_density(aes(group = disturbance, 
                   fill = disturbance_factor),alpha = 0.2) + 
  scale_fill_manual(values=c("#69b3a2", "#404080")) +
  theme(axis.text = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    axis.text.y = element_text(size = 8),
    legend.title = element_blank(), 
    legend.text = element_text(size = 8),
    legend.position = "bottom") +
  labs(title = indicator,
       x = "Indicator score",
       y = "Density") 
  
  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  distribution_plots_2[[i]] <- plot_grid(title,
                                         indicator_plots[[1]],
                                         indicator_plots[[2]],
                                         indicator_plots[[3]],
                                         # indicator_plots[[4]],
                                         # indicator_plots[[5]],
                                         nrow = 2, align = "v")
rm(indicator_plots, indicator)

}

distribution_plots_2[[1]]
distribution_plots_2[[2]]
distribution_plots_2[[3]]
distribution_plots_2[[4]]

```

# Visualise red list status breakdown changes over time

```{r red list status plots}

panel <- c("NA", "1", "2", "3")

scenario_extinctions <- list()
scenario_rl_status_plots <- list()

for (i in seq_along(scenario_redlist_data_sampled)) {
  
  # Add an ordered factor for plotting
  
  rl_status_fac <- factor(scenario_redlist_data_sampled[[i]]$rl_status,
      levels = c("LC", "NT", "VU", "EN", "CR", "EX"))
  
  scenario_redlist_data <- cbind(scenario_redlist_data_sampled[[i]],
  rl_status_fac = rl_status_fac)
  
  scenario_extinctions[[i]] <- scenario_redlist_data %>% 
          group_by(annual_time_step, rl_status_fac) %>% 
          filter(rl_status_fac != is.na(rl_status_fac)) %>% 
          summarise(red_list_status = n())
  
  scenario <- scenarios_title[[i]]
  
  # scenario_rl_status_plots[[i]] <- ggplot(scenario_extinctions[[i]], 
  #                                         aes(x = annual_time_step, 
  #                                             y = red_list_status, 
  #                                             fill = rl_status_fac)) +
  #   geom_bar(position = "stack", stat = "identity") +
  #   scale_fill_manual(values = c("#FDE725FF","#7AD151FF","#22A884FF","#2A788EFF",
  #                                "#414487FF","#440154FF")) +
  #   labs(title = scenarios_title[[i]])
  
 scenario_rl_status_plots[[i]] <- ggplot( scenario_extinctions[[i]],
                                          aes(x=annual_time_step, 
                                              y=red_list_status, 
                                              fill= rl_status_fac)) +
    geom_area( alpha = 0.7 ) +
   # scale_fill_manual(values = c("#FECC8FFF", "#FA815FFF","#D6456CFF",
   #                                "#802582FF","#400F73FF","#07071DFF")) +
   # scale_color_manual(values = c("#FECC8FFF", "#FA815FFF","#D6456CFF",
   #                                "#802582FF","#400F73FF","#07071DFF")) +
   scale_fill_manual(values = c("#07071DFF", "#400F73FF","#802582FF",
                                  "#D6456CFF","#FA815FFF","#FECC8FFF")) +
   scale_color_manual(values = c("#07071DFF", "#400F73FF","#802582FF",
                                  "#D6456CFF","#FA815FFF","#FECC8FFF")) +
   theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_rect(fill = "grey80"),
          legend.position = "bottom",
         legend.key.size = unit(0.25, 'cm'),
         plot.title = element_text(size = 10, face = "bold"),
         legend.title=element_text(size=6), 
         legend.text=element_text(size=6),
          axis.title.x = element_text(size=8),
          axis.title.y = element_text(size=8),
          axis.text.x = element_text(size=6),
          axis.text.y = element_text(size=6),
          axis.ticks.x = element_blank(), 
          axis.ticks.y = element_blank()) +
   labs(x = "Time (years)",
        y = "# species in Red List category") +
   guides(fill=guide_legend(title="Red List Status", nrow = 1)) +
  geom_vline(xintercept=c(100,200), linetype="dotted") 
   
  rm(scenario_redlist_data)
  
  ggsave(file.path(manuscript_plots_folder, paste(scenario,
                                                "RL_status_stacked_area_plots.png",
                                                sep = "_")),
       width = 10,
       height = 7,
       units = "cm",
       scenario_rl_status_plots[[i]])
  
}

scenario_rl_status_plots[[1]]
scenario_rl_status_plots[[2]]
scenario_rl_status_plots[[3]]
scenario_rl_status_plots[[4]]

```

# Visualise rates of change over time

Note, current bins are not based on much, there might be a more meaningful way to split them. 

```{r rate of change plots, warning=FALSE}

# CB friendly cols

tb_pal <- c("#3F3994FF","#18DEC1FF","grey60", "#D6E635FF", "#E14209FF","#7A0403FF")
#tb_pal_rev <- c("#7A0403FF", "#E14209FF", "#D6E635FF","grey50","#18DEC1FF", "#3F3994FF")
tb_pal_rev <- c("#7A0403FF", "#E14209FF", "grey50","#18DEC1FF", "#3F3994FF")

# * Bin rates of change and plot them ----

# set_breaks <- c(-3,-0.0894307914, -0.0166148404, 0,
#                 0.0147363530, 0.3069022173, 3)

set_breaks <- c(-3, -0.05, -0.008,
                0.008, 0.05, 3)

set_breaks <- round(set_breaks, 4)

#set_breaks <- c(3, 0.3069022173,0.0147363530,-0.0003499485,-0.0166148404,-0.0894307914,-3)

rate_of_change_plots <- list()
rate_of_change_data <- list()

for (i in seq_along(scenario_redlist_data_sampled)) {
  
scenario <- scenarios_title[[i]]
   
   
rate_of_change_data[[i]] <- bin_rates_of_change(scenario_redlist_data_sampled[[i]],
                                        set_breaks) %>% 
                                        mutate(scenario = scenarios[[i]])

# plot_data <- rate_of_change_data[[i]] %>% 
#              dplyr::select(-group_id, - ave_abundance, - functional_group_name) %>% 
#              distinct(.)

plot_data <- rate_of_change_data[[i]] %>% 
             dplyr::select(- ave_abundance, - functional_group_name) %>%
             distinct(.) 
  
rate_of_change_plots[[i]] <- ggplot(plot_data,
                                    aes(x = annual_time_step, 
                                        y = prop_declining,
                                        fill = dt_bins)) +
                                        #fill = reorder(dt_bins, desc(dt_bins)))) +
  geom_area(position="stack", stat="identity", alpha = 0.7) +
   scale_fill_manual(values = tb_pal_rev) +
   scale_color_manual(values = tb_pal_rev) +
   #scale_fill_viridis_d() +
   labs(x = "Time (years)",
        y = "Proportion of species in change category") +
   guides(fill = guide_legend(title = "Rate of change category",
                              nrow = 1)) +
    geom_vline(xintercept=c(100,200), linetype="dotted") +
   plot_theme +
  scale_y_reverse()


  ggsave(file.path(manuscript_plots_folder, paste(scenario,
                                                "change_rate_stacked_bar_plots.png",
                                                sep = "_")),
       width = 14,
       height = 9,
       units = "cm",
       rate_of_change_plots[[i]])
   
  rm(plot_data)
  
}

rate_of_change_plots[[1]]
rate_of_change_plots[[2]]
rate_of_change_plots[[3]]
rate_of_change_plots[[4]]

```

```{r most declining spp}

library(directlabels)

declining_species_plots <- list()

set.seed(354)

for (i in seq_along(rate_of_change_data)) {
  
declining <- rate_of_change_data[[i]] %>% 
             group_by(group_id) %>% 
             filter(any(dt_bins == "[-3,-0.0894)")) %>% 
             distinct(.)

groups <- unique(declining$group_id)

group_sample <- sample(groups, size = 12)
group_sample <- as.data.frame(group_sample)

declining <- declining[declining$group_id %in% group_sample$group_sample,] 


declining_species_plots[[i]] <- ggplot(data = declining, aes(annual_time_step, 
                                                             log(ave_abundance), 
                             group = group_id, 
                             col = dt_bins)) +
  geom_line() +
  theme(legend.position = "bottom") +
  geom_dl(aes(label = group_id), method = "last.points", cex = 0.8) 

}

declining_species_plots[[1]]
declining_species_plots[[2]]
declining_species_plots[[3]]
declining_species_plots[[4]]

```

# Functional group density over time

Note this does not show relative abundance, it shows the proportion of abundance
for each functional group in that time step, relative to it's total abundance
over the entire time series.

```{r plot density by functional group, warnings = FALSE}

scenario_fg_abundance <- list()

for (i in seq_along(scenario_redlist_data_sampled)) {
  
  scenario_fg_abundance[[i]] <- scenario_redlist_data_sampled[[i]] %>% 
    mutate(scenario = scenarios[[i]]) %>% 
    ungroup(.) %>% 
    group_by(functional_group_name, annual_time_step) %>% 
    mutate(indicator_score = mean(ave_abundance, na.rm = TRUE),
           indicator = "total abundance",
           ci_lower = NA,
           ci_upper = NA,
           replicate = NA) %>% 
    ungroup(.) %>%                                 
    dplyr::select(annual_time_step, 
                  indicator_score,
                  ci_lower,
                  ci_upper,
                  indicator,
                  replicate,
                  functional_group_name,
                  scenario) %>% 
    distinct(.) %>%
    group_by(functional_group_name)  %>% 
    mutate(indicator_score = indicator_score/first(indicator_score),
           density = indicator_score/sum(indicator_score, na.rm = TRUE)) %>% 
    ungroup(.) %>% 
    group_by(annual_time_step) %>% 
    mutate(total_density = sum(density, na.rm = TRUE)) %>% 
    group_by(annual_time_step, functional_group_name) %>% 
    mutate(perc_density = density/total_density)
  
}

library(ggridges)

func_group_perc_density_plots <- list()

for (i in seq_along(scenario_fg_abundance)) {
  
func_group_perc_density_plots[[i]] <- ggplot(scenario_fg_abundance[[i]], 
                            aes(x = annual_time_step, 
                                y = functional_group_name,
                                height = density,
                                group = functional_group_name,
                                color = functional_group_name,
                                fill = functional_group_name)) + 
      geom_density_ridges(stat = "identity", scale = 0.8, alpha = 0.6) +
  theme_classic() +
  labs(title = scenario_fg_abundance[[i]]$scenario[1])

}

func_group_perc_density_plots[[1]]
func_group_perc_density_plots[[2]]
func_group_perc_density_plots[[3]]
func_group_perc_density_plots[[4]]

```

```{r species density, warnings = FALSE}

# * Plot density of species ----

scenario_species_abundance <- list()

for ( i in seq_along(scenario_redlist_data_sampled)) {
  
  scenario_species_abundance[[i]] <- scenario_redlist_data_sampled[[i]] %>% 
    mutate(scenario = scenarios[[i]]) %>% 
    ungroup(.) %>% 
    group_by(group_id, annual_time_step) %>% 
    mutate(indicator_score = mean(ave_abundance, na.rm = TRUE),
           indicator = "total abundance",
           ci_lower = NA,
           ci_upper = NA,
           replicate = NA) %>% 
    ungroup(.) %>%                                 
    dplyr::select(annual_time_step, 
                  indicator_score,
                  ci_lower,
                  ci_upper,
                  indicator,
                  replicate,
                  group_id,
                  functional_group_name,
                  scenario,
                  mass_range_kg) %>% 
    distinct(.) %>%
    group_by(group_id)  %>% 
    mutate(indicator_score = indicator_score/first(indicator_score),
           density = indicator_score/sum(indicator_score, na.rm = TRUE)) %>% 
    ungroup(.)
  
}

scenario_species_abundance_plots <- list()

for(i in seq_along(scenario_species_abundance)) {
  
  split_data <- split(scenario_species_abundance[[i]], 
                      scenario_species_abundance[[i]]$functional_group_name)
  fg_plots <- list()
  for (j in seq_along(split_data)){
    
    fg <- split_data[[j]]$functional_group_name[1]
    
    fg_plots[[j]] <- ggplot(split_data[[j]], 
                            aes(x = annual_time_step, 
                                y = group_id,
                                height = density,
                                group = group_id,
                                color = group_id,
                                fill = group_id)) + 
      geom_density_ridges(stat = "identity", scale = 1, alpha = 0.6) +
      theme_classic() +
      theme(panel.background = element_rect(fill = "snow2"),
            legend.position = "none",
            strip.text = element_text(face="bold", size=9)) +
      geom_vline(xintercept = 100, linetype = "dashed") +
      # annotate(x=100,y=+Inf,label="Impact start",vjust=2,geom="label",
      #          size = 3) +
      geom_vline(xintercept = 200, linetype = "dashed") +
      # annotate(x=200,y=+Inf,label="Impact end",vjust=2,geom="label",
      #          size = 3) +
      labs(x = "Annual time step",
           y = "Density over time",
           title = fg) + 
      theme(plot.title = element_text(size = 10))  + 
      theme(axis.text.x = element_text(size = 1))
    
   }
  
  scenario_species_abundance_plots[[i]] <- fg_plots
  
}

scenario_species_abundance_plots[[1]][[4]]
```

# Baseline - Species density over time

```{r baseline spp density}

p <- 4

title <- ggdraw() + draw_label("Baseline", fontface='bold') 
title2 <- ggdraw() + draw_label(" ", fontface='bold')  
 
bl_spp_density <- plot_grid(title, title2,
                            scenario_species_abundance_plots[[1]][[1]],
                            scenario_species_abundance_plots[[1]][[2]],
                            scenario_species_abundance_plots[[1]][[3]],
                            scenario_species_abundance_plots[[1]][[4]],
                            scenario_species_abundance_plots[[1]][[5]],
                            scenario_species_abundance_plots[[1]][[6]],
                            nrow = p, align = "v")

bl_spp_density

ggsave(file.path(supporting_info_plots_folder, "baseline_spp_density.pdf"),
       bl_spp_density,  width = 10, height = 18, dpi = 300, 
       units = "in",device = "pdf")

scenario_species_abundance_plots[[1]][[5]]

```

# Land use - Species density over time

```{r land use spp density, out.width = '100%', out.height='60%'}

title <- ggdraw() + draw_label("Land use", fontface='bold')  

lu_spp_density <- plot_grid(title, title2,
                            scenario_species_abundance_plots[[2]][[1]],
                            scenario_species_abundance_plots[[2]][[2]],
                            scenario_species_abundance_plots[[2]][[3]],
                            scenario_species_abundance_plots[[2]][[4]],
                            scenario_species_abundance_plots[[2]][[5]],
                            scenario_species_abundance_plots[[2]][[6]],
                            nrow = p, align = "v")

lu_spp_density

ggsave(file.path(supporting_info_plots_folder, "land_use_spp_density.pdf"),
       lu_spp_density,  width = 10, height = 18, dpi = 300, 
       units = "in",device = "pdf")

```

# Carnivore harvesting - Species density over time

```{r carnivore spp density, out.width = '100%', out.height='60%' }

title <- ggdraw() + draw_label("Carnivore harvesting", fontface='bold')  

ca_spp_density <- plot_grid(title, title2,
                            scenario_species_abundance_plots[[3]][[1]],
                            scenario_species_abundance_plots[[3]][[2]],
                            scenario_species_abundance_plots[[3]][[3]],
                            scenario_species_abundance_plots[[3]][[4]],
                            scenario_species_abundance_plots[[3]][[5]],
                            scenario_species_abundance_plots[[3]][[6]],
                            nrow = p, align = "v")

ca_spp_density

ggsave(file.path(supporting_info_plots_folder, "carnivore_spp_density.pdf"),
       ca_spp_density,  width = 10, height = 18, dpi = 300, 
       units = "in",device = "pdf")

```

# Herbivore harvesting - Species density over time

```{r herbivore spp density, out.width = '100%', out.height='60%' }

title <- ggdraw() + draw_label("Herbivore harvesting", fontface='bold')  

he_spp_density <- plot_grid(title,
                            title2,
                            scenario_species_abundance_plots[[4]][[1]],
                            scenario_species_abundance_plots[[4]][[2]],
                            scenario_species_abundance_plots[[4]][[3]],
                            scenario_species_abundance_plots[[4]][[4]],
                            scenario_species_abundance_plots[[4]][[5]],
                            scenario_species_abundance_plots[[4]][[6]],
                            nrow = p, align = "v")
he_spp_density

ggsave(file.path(supporting_info_plots_folder, "herbivore_spp_density.pdf"),
       he_spp_density,  width = 10, height = 18, dpi = 300, 
       units = "in",device = "pdf")

```

# Get important groups (based on the plots above)

```{r get important groups}

# This input file was made by hand after eyeballing the plots above to see which
# groups affect dynamics

important_groups <- read.csv(file.path(analysis_inputs,
                                       "2021-09-30",
                                       "important_groups.csv"))

important_list <- split(important_groups, important_groups$scenario)

scenario_important_abundance <- list()

for (i in seq_along(scenario_redlist_data_sampled)) {
  
ig <- important_list[[i]]$group_id

# Get just the groups important for that scenario
subset_data <- scenario_redlist_data_sampled[[i]][
  scenario_redlist_data_sampled[[i]]$group_id %in% ig, ]

scenario_important_abundance[[i]] <-  subset_data %>% 
      merge(important_list[[i]][c("group_id", "reason", "X")], by = "group_id") %>% 
      mutate(scenario = important_list[[i]]$scenario[1]) %>% 
      ungroup(.) %>% 
      dplyr::select(annual_time_step, group_id, ave_abundance, scenario, reason,
                    rl_status, X) %>% 
      distinct(.) %>% 
      group_by(group_id) %>% 
      mutate(indicator_score = standardize(ave_abundance),
             indicator = reason,
             ci_lower = NA,
             ci_upper = NA,
             replicate = NA) %>% #this is a misuse of replicate column
      ungroup(.) %>% 
      dplyr::select(annual_time_step,
                    group_id,
                    indicator_score,
                    ci_lower,
                    ci_upper,
                    indicator,
                    replicate,
                    scenario,
                    rl_status, X) %>% 
      distinct(.)

}

saveRDS(scenario_important_abundance, file.path(analysis_inputs, input_date, "scenario_important_group_abundance.rds"))


test <- do.call(rbind, scenario_important_abundance)
#test <- scenario_important_abundance[[3]]
test_plot <- ggplot(test, aes(annual_time_step, indicator_score, group = group_id,
                 col = X)) +
  geom_smooth(method = 'loess', span = 0.25) +
  facet_wrap( ~ scenario)

ggsave(file.path(manuscript_plots_folder, "trophic_group_abundance.png"),
       test_plot,  width = 10, height = 8, dpi = 300, 
       units = "in",device = "png")

```
# Plot red list status trajectory against abundance

```{r rli trajectory plots}

all_abundance <- do.call(rbind, scenario_important_abundance)

data <- all_abundance %>% 
        dplyr::filter(scenario == "100_Land_use" & group_id == "13.16.6"|
               scenario == "300_Harvesting_herbivores"& group_id == "10.68"|
               scenario == "200_Harvesting_carnivores"& group_id == "10.69")

rl_status_fac <- factor(data$rl_status,
      levels = c("LC", "NT", "VU", "EN", "CR", "EX"))
  
data2 <- cbind(data,
         rl_status_fac = rl_status_fac)

plot <- ggplot(data2, aes(annual_time_step,indicator_score,
                 col = rl_status_fac, group = group_id)) +
  geom_line(size = 2) +
  theme(legend.position = "bottom") +
  facet_wrap(~ group_id, nrow = 3) +
  # scale_color_manual(values = c("#440154FF", "#414487FF","#2A788EFF",
  #                                 "#22A884FF","#7AD151FF","#FDE725FF")) +
  scale_color_manual(values = c("#07071DFF", "#400F73FF","#802582FF",
                                  "#D6456CFF","#FA815FFF","#FECC8FFF")) +
  theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_rect(fill = "grey80"),
          legend.position = "bottom",
         legend.key.size = unit(1, 'cm'),
         plot.title = element_text(size = 10, face = "bold"),
         legend.title=element_text(size=6), 
         legend.text=element_text(size=6),
          axis.title.x = element_text(size=8),
          axis.title.y = element_text(size=8),
          axis.text.x = element_text(size=6),
          axis.text.y = element_text(size=6),
          axis.ticks.x = element_blank(), 
          axis.ticks.y = element_blank()) +
   labs(x = "Time (years)",
        y = "Standardized abundance") +
  guides(col=guide_legend(title="Red List Status", nrow = 1)) +
  geom_vline(xintercept=c(100,200), linetype="dotted") 
  

plot

ggsave(file.path(manuscript_plots_folder, "red_list_v_abundance.png"),
       plot,  width = 10, height = 8, dpi = 300, 
       units = "in",device = "png")


```


```{r plot differenced, eval = FALSE}

differenced_plots <- list()

for (i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
  
  # Get the indicator name
  
  indicator <- single_scenario[[j]]$indicator[1]


indicator_plots[[j]] <- ggplot(data = single_scenario[[j]], 
                               aes(x = annual_time_step,
                                   y = indicator_score_diff)) +
  geom_line() + 
  theme(axis.text = element_text(size = 2),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6)) +
  labs(title = indicator,
       x = "Annual time step",
       y = "Differenced indicator score") 

  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  differenced_plots[[i]] <- plot_grid(title,
                                         indicator_plots[[1]],
                                         indicator_plots[[2]],
                                         indicator_plots[[3]],
                                         # indicator_plots[[4]],
                                         # indicator_plots[[5]],
                                         nrow = 2, align = "v")
rm(indicator_plots, indicator)

}

differenced_plots[[1]]
differenced_plots[[2]]
differenced_plots[[3]]
differenced_plots[[4]]

```


```{r plot temporal variance, warning=FALSE, error = FALSE, message=FALSE, eval = FALSE}

variance_plots_3 <- list()

for (i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
  
  # Get the indicator name
  
  indicator <- single_scenario[[j]]$indicator[1]


indicator_plots[[j]] <- ggplot(data = single_scenario[[j]], 
                               aes(x = annual_time_step,
                                   y = variance)) +
  geom_line() + 
  theme(axis.text = element_text(size = 2),
    axis.text.x = element_text(size = 6),
    axis.text.y = element_text(size = 6)) +
  labs(title = indicator,
       x = "Annual time step",
       y = "Temporal variance") 

  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  variance_plots_3[[i]] <- plot_grid(title,
                                         indicator_plots[[1]],
                                         indicator_plots[[2]],
                                         indicator_plots[[3]],
                                         indicator_plots[[4]],
                                         indicator_plots[[5]],
                                         nrow = 2, align = "v")
rm(indicator_plots, indicator)

}

variance_plots_3[[1]]
variance_plots_3[[2]]
variance_plots_3[[3]]
variance_plots_3[[4]]

```

```{r trend modeling example, eval = FALSE}

# Using the demo data
head(ind_ex)
head(press_ex)
head(press_type_ex)
# Scoring template:
crit_scores_tmpl

m_trend <- model_trend(ind_tbl = ind_ex[ ,-1],
  time = ind_ex$Year)

# Model diagnostics
pd <- plot_diagnostics(model_list = m_trend$model)
pd$all_plots[[1]] # first indicator
# check for outliers in all models
grid.arrange(grobs = pd$cooks_dist, ncol = 3)
# check normality in all models
grid.arrange(grobs = pd$qq_plot, ncol = 3)
# check homogeneity in all models
grid.arrange(grobs = pd$resid_plot, ncol = 3)
# check for autocorrelation in all models
grid.arrange(grobs = pd$acf_plot, ncol = 3)
# check for partial autocorrelation in all models
grid.arrange(grobs = pd$pacf_plot, ncol = 3)

# Save diagnostic plots per indicator in a pdf
ml <- marrangeGrob(grobs = pd$all_plots, ncol = 1, nrow = 1)
ml
ggsave("Trend_diagnostics.pdf", ml, height = 8, width = 12)

# Inspect trends
pt <- plot_trend(m_trend)
pt$TZA # shows trend of TZA indicator
# show all together
ml <- grid.arrange(grobs = pt, ncol = 3)
ml
# save as pdf
ggsave("Trend_plots.pdf", ml, height = 12, width = 15)
# show only significant trends
grid.arrange(
  grobs = pt[which(m_trend$p_val <= 0.05)],
  ncol = 2
    )

```

```{r prepare data for trend modelling, eval = FALSE }

# Get one scenario
single_scenario <- indicators_all_df %>%
                   filter(scenario == "100_Land_use") %>%
                   dplyr::select(annual_time_step, indicator, indicator_score)

single_scenario <- as.data.frame(single_scenario)

# Conver to wide format

ind_trend_inputs <- single_scenario %>%
                    pivot_wider(names_from = indicator,
                                values_from = indicator_score) %>%
                    arrange(annual_time_step)

pressure_inputs <- single_scenario %>%
                   filter(indicator == "total abundance harvested") %>%
                   pivot_wider(names_from = indicator,
                                values_from = indicator_score) %>%
                   arrange(annual_time_step)
                    

```

```{r model trends and plot diagnostics, eval = FALSE }

m_trend <- model_trend(ind_tbl = ind_trend_inputs[ ,-1],
  time = ind_trend_inputs$annual_time_step,
  family = stats::Gamma())

# Model diagnostics
pd <- plot_diagnostics(model_list = m_trend$model)
pd$all_plots[[1]] # first indicator
pd$all_plots[[2]]
pd$all_plots[[3]]

# Save diagnostic plots per indicator in a pdf
ml <- marrangeGrob(grobs = pd$all_plots, ncol = 1, nrow = 1)

# ggsave(file.path(analysis_plots_folder,
#                  "Trend_diagnostics.pdf"),
#                  ml, height = 8, width = 12)

```

```{r plot trends , eval = FALSE}

# Inspect trends
pt <- plot_trend(m_trend)
pt$RLI_annual # shows trend of TZA indicator
# show all together
ml <- grid.arrange(grobs = pt, ncol = 3)
ml
# save as pdf
ggsave("Trend_plots.pdf", ml, height = 12, width = 15)
# show only significant trends
grid.arrange(
  grobs = pt[which(m_trend$p_val <= 0.05)],
  ncol = 2
    )


```

```{r prepare data for pressure - response modelling, eval = FALSE }

dat_init <- ind_init(ind_tbl = ind_trend_inputs[ ,-1],
  press_tbl = pressure_inputs[ ,-1], time = ind_trend_inputs$annual_time_step,
    train = 0.9, random = FALSE)

```

```{r simple gams, eval = FALSE }

m_gam <- model_gam(init_tbl = dat_init, k = 5,
    family = stats::Gamma(), excl_outlier = NULL)

# Model diagnostics
pd <- plot_diagnostics(model_list = m_gam$model)  # (might take a while)
ml <- marrangeGrob(grobs = pd$all_plots, ncol = 1, nrow = 1)
ggsave("GAM_diagnostics.pdf", ml, height = 8, width = 12)

# Any outlier?
m_gam$pres_outlier %>% purrr::compact(.)
# - get number of models with outliers detected
purrr::map_lgl(m_gam$pres_outlier, ~!is.null(.)) %>% sum()
# - which models and what observations?
m_gam %>%
    dplyr::select(id, ind, press, pres_outlier) %>%
    dplyr::filter(!purrr::map_lgl(m_gam$pres_outlier, .f = is.null)) %>%
    tidyr::unnest(pres_outlier)

# Exclude outlier in models (using the returned model output tibble as selector)
m_gam <- model_gam(init_tbl = dat_init, excl_outlier = m_gam$pres_outlier)

# Any temporal autocorrelation (TAC)
sum(m_gam$tac)

# - which models
m_gam %>%
    dplyr::select(id, ind, press, tac) %>%
    dplyr::filter(tac)

```

```{r GAMMs for temporally autocorrelated, eval = FALSE }

m_gamm <- model_gamm(init_tbl = dat_init,
  filter = m_gam$tac, # (apply GAMM only to rows where TAC detected)
  family = Tweedie(p = 2)) 

# Again, any outlier?
purrr::map_lgl(m_gamm$pres_outlier, ~!is.null(.)) %>% sum()

# Select best GAMM from different correlation structures
# (based on AIC)
best_gamm <- select_model(gam_tbl = m_gam, gamm_tbl = m_gamm)
View(best_gamm)

# Still any temporal autocorrelation?
sum(best_gamm$tac)
# - which models
best_gamm %>%
  dplyr::select(id, ind, press, tac, corrstruc) %>%
  dplyr::filter(tac) %>%
  print(n = 100)

# Inspect diagnostic plots of best GAMMs
pd <- plot_diagnostics(model_list = best_gamm$model)
ml <- marrangeGrob(grobs = pd$all_plots, ncol = 1, nrow = 1)
ggsave(file.path(analysis_plots_folder, "bestGAMM_diagnostics.pdf"),
       ml, height = 8, width = 12)

 

```

```{r merge GAMS and GAMMS, eval= FALSE }
m_merged <- merge_models(m_gam[m_gam$tac == FALSE, ], best_gamm)

# View sign. models
filter(m_merged, p_val <= 0.05) %>%
  View()

sel <- find_id(
    mod_tbl = m_merged, 
    ind_name = indicators
)$id

m_merged$nrmse[sel] <- calc_nrmse(
    press = ind_init_ex$press_test[sel], 
    ind = ind_init_ex$ind_test[sel],
    model = m_merged$model[sel], 
    transformation = "log"
)

m_all <- m_merged

print("test")

```

```{r calculate derivatives, eval = FALSE}
# WARNING SLOW CODE
m_calc <- calc_deriv(init_tbl = dat_init, mod_tbl = m_merged,
    sign_level = 0.05)

```

```{r interactions, eval = FALSE }

it <- select_interaction(mod_tbl = m_calc)
# (creates combinations to test for)

m_all <- test_interaction(init_tbl = dat_init, mod_tbl = m_calc,
     interactions = it, sign_level = 0.05)

m_works <- m_all[-c(1,2), ]

# Inspect diagnostics of threshold models
pd_thresh <- m_works %>%
    # flatten structure of nested threshold GAMs 
    flatten() %>%
    # and remove empty lists (where no threshold GAMs were applied (=NULL) 
    # or no threshold GAMs were better than the simple GAMs (=NA)
    keep(~is.list(.x))  %>%
    plot_diagnostics()

ml <- marrangeGrob(grobs = pd_thresh$all_plots, ncol = 1, nrow = 1)
ggsave(file.path(analysis_plots_folder, "thresholdGAM_diagnostics.pdf"), 
       ml, height = 8, width = 10)

# Look at the development of the generalized cross-validation value 
# at different thresholds level: the plot should show that the GCVV
# of the final threshold should be clearly lower than of others 
# (you should see a single sharp trough, not at the edge)
grid.arrange(grobs = pd_thresh$gcvv_plot, ncol = 3)
# -> some models do NOT show this (e.g. #4,6,7): here we could set the
#  $interaction from TRUE to FALSE (for the scoring later) to ignore
# this potentially spurious interaction found:
m_all <- m_all %>% mutate(
    interaction = case_when(
    (ind == "Micro" & press == "Fsprat") |
        (ind == "Cod" & press == "Fher") | 
        (ind == "Cod" & press == "Fcod") ~ FALSE,
    TRUE ~ interaction))

```

```{r plot models,  eval = FALSE }


# Show final significant GAM/GAMM (threshold GAM) plots:
sel <- which(m_all$p_val <= 0.05)
pm <- plot_model(init_tbl = dat_init[sel, ], mod_tbl = m_all[sel, ])
# Save all sign. indicator plots
ml <- gridExtra::marrangeGrob(grobs = pm$all_plots, ncol = 1, nrow = 1)
ggplot2::ggsave(file.path(analysis_plots_folder, "Final_model_results.pdf"), 
                          ml, height = 10, width = 12)

```

```{r make my own GAMM,  eval = FALSE }

# * LPI ----
# *** Prep inputs ----

unique(indicators_all_df$indicator)
unique(indicators_all_df$scenario)
ind <- "LPI"
scen <- "100_Land_use"

response <- indicators_all_df %>% 
  filter(indicator == ind) %>% 
  filter(scenario == scen) %>% 
  rename(LPI = indicator_score)

predictor <- indicators_all_df %>% 
  filter(indicator == "total abundance harvested") %>% 
  filter(scenario == scen) %>% 
  rename(harvested = indicator_score) %>% 
  mutate(disturbance = ifelse(annual_time_step < 100|
                                annual_time_step > 200,
                              0, 1))

pr_gam_inputs <- response %>% 
  merge(predictor, by = "annual_time_step") %>% 
  mutate(LPI_scaled = scale(LPI),
         harvested_scaled = scale(harvested))

head(pr_gam_inputs)
summary(pr_gam_inputs)

# *** Fit trend models ----

hist(pr_gam_inputs$LPI_scaled, 60)
hist(pr_gam_inputs$harvested_scaled, 60)

m1 <- gam(LPI ~ s(annual_time_step) +
             s(harvested, k = 100), 
           data = pr_gam_inputs,
          family = Tweedie(p = 2))

gam.check(m1)
summary(m1)
plot(m1,pages=1)

m2 <- gam(LPI ~ s(annual_time_step, k = 100), 
          data = pr_gam_inputs,
          method = "GCV.Cp",
          select = TRUE,
          family = Tweedie(p = 2, link = "log"))

gam.check(m2)

m3 <- gamm(LPI ~ s(annual_time_step, k = 100), 
                 data = pr_gam_inputs,
                 correlation = corARMA(form = ~ annual_time_step, p = 1),
           family = Tweedie(p= 2, link = "log"))


# *** Model selection ----

## Using AIC
mod_sel_table <- as.data.frame(AIC(m1, m2, m3$lme))
mod_sel_table

# Define selected model

selected_mod <- m2

plot(selected_mod, residuals = TRUE, pch = 19, cex = 0.75)

```

```{r plot selected mods, eval = FALSE}

summary(pr_gam_inputs)

pdat <- data.frame(annual_time_step = seq(1, 295, 1))

head(pdat)

p <- predict(selected_mod, newdata = pdat, type = "response")
p
lines(p ~ annual_time_step, data = pdat, col = "pink")
# lines(p1 ~ annual_time_step, data = pdat, col = "red")
# lines(p2 ~ annual_time_step, data = pdat, col = "blue")
legend("topleft",
       legend = c("Uncorrelated Errors","AR(1) Errors"),
       bty = "n", col = c("red","blue"), lty = 1)

# *** Plot the derivatives and periods of change ----

m2.d <- Deriv(selected_mod$terms, n = 300)
plot(m2.d, sizer = TRUE, alpha = 0.01)

# Add periods of change to time series

plot(LPI ~ annual_time_step, data = pr_gam_inputs, 
     type = "p")
lines(p ~ annual_time_step, data = pdat)
CI <- confint(m2.d, alpha = 0.01)
S <- signifD(p, m2.d$annual_time_step$deriv, 
             CI$annual_time_step$upper, 
             CI$annual_time_step$lower,
             eval = 0)
lines(S$incr ~ annual_time_step, data = pdat, lwd = 3, col = "blue")
lines(S$decr ~ annual_time_step, data = pdat, lwd = 3, col = "red")
# Recreate with ggplot

deriv_plot <- ggplot() +
  geom_point(data = gam_inputs,
             aes(x = annual_time_step, y = indicator_score),
             alpha = 0.3) +
  geom_line(aes(x = gam_inputs$annual_time_step,
                y = p2)) +
  geom_line(aes(x = gam_inputs$annual_time_step, 
                y = S$incr), col = "blue", size = 2) +
  geom_line(aes(x = gam_inputs$annual_time_step, 
                y = S$decr), col = "red", size = 2) +
  labs(title = paste(gam_inputs$scenario[1],
                     gam_inputs$indicator[1], sep = " "))

deriv_plot

ggsave(file.path(analysis_plots_folder,
                 paste(gam_inputs$indicator[1],"_", gam_inputs$scenario[1], 
                       "derivative_plot.png", sep = "")),
       deriv_plot,  device = "png")

```
