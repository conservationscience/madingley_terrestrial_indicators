---
title: "Analyse terrestrial indicators"
author: "Simone Stevenson"
date: "20/09/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}

# https://bookdown.org/yihui/rmarkdown/r-code.html

knitr::opts_chunk$set(echo = FALSE, message = FALSE,
  warnings = FALSE, error = FALSE)
```

Directory path to git repo

Simone's deakin laptop

cd "C:\\Users\\ssteven\\OneDrive - Deakin University\\Deakin\\Chapter_3_indicator_testing\\madingley_terrestrial_indicators"

Data structure

Input data is structured hierarchically as follows:
- Location (1)
-- Scenarios (3)
--- Replicates (25)

Output indicator data is calculated at the same level, so each indicator should
have values for:
- Location (1)
-- Scenarios (3)
--- Replicates (25)

```{r libraries}

## Data wrangling
library(tidyverse)
library(tidylog)

## Analysis
library(mgcv)
library(nlme)
library(changepoint)
library(MASS)
library(strucchange)
library(datawizard)
#devtools::install_github("saskiaotto/INDperform")
library(INDperform)

## Viz
library(ggpubr)
library(cowplot)
library(gridExtra)

```

```{r functions, echo=FALSE, eval=FALSE}

#' Description

#' @param 
#' @param 
#' @param 
#' @return 

function_name <- function(param){

}

```

```{r template chunk }

```

```{r data }

# Set up paths ----

location <- 'Serengeti'

indicators_project <- "N:/Quantitative-Ecology/Indicators-Project"

# Analysis inputs are the outputs of 2_calculate_madingley_indicators.R

analysis_inputs <- "N:/Quantitative-Ecology/Indicators-Project/Serengeti/Outputs_from_indicator_code/Indicator_outputs/general/"

# Inputs ----

# Specify the date of inputs you want to use

input_date <- "2021-09-22"

# Get date to label outputs

output_date <- Sys.Date() 

scenarios_title <- list("Baseline", "Land use", 
                  "Carnivore harvesting", 
                  "Herbivore harvesting")

disturbance_string <- c("pre-disturbance", "disturbance", "post-disturbance")

disturbance_factor <- factor(disturbance_string, ordered = TRUE,
                              levels = c("pre-disturbance", 
                                         "disturbance", 
                                         "post-disturbance"))

# Set up output folders

## Include a folder to store the version of inputs used to get the outputs

analysis_inputs_folder <- file.path(indicators_project,  
                           "/Serengeti/Outputs_from_analysis_code/Analysis_inputs",
                           output_date)

if( !dir.exists( file.path(analysis_inputs_folder) ) ) {
  dir.create( file.path(analysis_inputs_folder), recursive = TRUE )
  
}

analysis_outputs_folder <- file.path(indicators_project, 
                                     "/Serengeti/Outputs_from_analysis_code/Analysis_outputs",
                                     output_date)

if( !dir.exists( file.path(analysis_outputs_folder) ) ) {
  dir.create( file.path(analysis_outputs_folder), recursive = TRUE )
  
}

analysis_plots_folder <- file.path(indicators_project, 
                                     "/Serengeti/Outputs_from_analysis_code/Analysis_plots_folder",
                                   output_date)

if( !dir.exists( file.path(analysis_plots_folder) ) ) {
  dir.create( file.path(analysis_plots_folder), recursive = TRUE )
  
}

# Load indicator > scenario level data ----

indicators_all_df <- readRDS(file.path(analysis_inputs, input_date, "all_indicators_output_dataframe.rds"))

indicators_all_list <- flatten(readRDS(file.path(analysis_inputs,input_date, "all_indicators_output_list.rds")))

# Get list of indicators

indicators <- unique(indicators_all_df$indicator)

# Get list of scenarios

scenarios <- unique(indicators_all_df$scenario)

# Save a copy of the inputs used to create outputs

write.csv(indicators_all_df, file.path(analysis_inputs_folder,
                                       paste(output_date, "input_data.csv",
                                             sep = "_")))
# Load red list data

scenario_redlist_data_sampled <- readRDS(file.path(analysis_inputs, input_date, "scenario_redlist_data_annual_7.rds"))
```

# Plot the raw indicator score, the standardized score, the differenced score and the temporal variance

Using the annual RLI in Land use scenario as an example

```{r prep data}

# Standardize & difference the data as per Bestelmeyer 2011

indicators_all_df <- indicators_all_df %>% 
                     group_by(indicator, scenario) %>% 
                     mutate(indicator_score_std = standardize(indicator_score),
                            indicator_score_diff = indicator_score_std - 
                             lag(indicator_score_std, default = 0)) %>% 
                     mutate(variance = rollapply(indicator_score_diff,
                               10,
                               var,
                               na.rm = TRUE,
                               partial = TRUE,
                               align = "left"),
                            disturbance = as.integer(ifelse(annual_time_step > 99 &
                                                 annual_time_step < 201,
                                                 1, 0)),
                            disturbance_factor = as.factor(ifelse(disturbance == 1,
                                                 "disturbance", 
                                                 "no disturbance"))) %>%
                     ungroup(.)


# Split into a list of scenarios then indicators

scenario_indicators <- split(indicators_all_df, indicators_all_df$scenario)

# Or vice versa

indicator_scenarios <- split(indicators_all_df, indicators_all_df$indicator)

# Single indicator, single scenario

scenario_indicator_single <- split(indicators_all_df,
                                   list(indicators_all_df$scenario,
                                   indicators_all_df$indicator))

# Make a test df of one scenario, one indicator for building loop content

test_df <- scenario_indicators[[2]] %>% 
           filter(indicator == "LPI")

```

# Visualise smoothed time series using loess at 10, 25 and 50% smoothing spans

```{r visualise, warning=FALSE, message = FALSE, error=FALSE}

# Visualise smoothed time series using loess as in Bestelmeyer 2011

# http://r-statistics.co/Loess-Regression-With-R.html

loess_plots_1 <- list()

for ( i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicators <- names(single_scenario)
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
    
  # Get the scenario
  
  indicator <- single_scenario[[j]]$indicator[1]


loessMod10 <- loess(indicator_score_std ~ annual_time_step, 
                    data = single_scenario[[j]], span=0.10) # 10% smoothing span
loessMod25 <- loess(indicator_score_std ~ annual_time_step, 
                    data = single_scenario[[j]], span=0.25) # 25% smoothing span
loessMod50 <- loess(indicator_score_std ~ annual_time_step, 
                    data = single_scenario[[j]], span=0.50) # 50% smoothing span

# get smoothed output
smoothed10 <- as.data.frame(cbind(annual_time_step = single_scenario[[j]]$annual_time_step, 
                            indicator_score_loess = predict(loessMod10))) 

smoothed25 <-  as.data.frame(cbind(annual_time_step = single_scenario[[j]]$annual_time_step, 
                            indicator_score_loess = predict(loessMod25)))

smoothed50 <-  as.data.frame(cbind(annual_time_step = single_scenario[[j]]$annual_time_step, 
                            indicator_score_loess = predict(loessMod50)))

indicator_plots[[j]] <- ggplot() +
  geom_point(data = single_scenario[[j]], aes(annual_time_step, 
                                              indicator_score_std),
             alpha = 0.2) +
  geom_line(data = smoothed10, aes(x = annual_time_step, y = indicator_score_loess), col = "red") + theme(axis.text = element_text(size = 2),
    axis.text.x = element_text(size = 1),
    axis.text.y = element_text(size = 1)) +
  geom_line(data = smoothed25, aes(annual_time_step, indicator_score_loess), col = "green") +
  geom_line(data = smoothed50, aes(annual_time_step, indicator_score_loess), col = "blue") +
  labs(title = indicator,
       x = "Annual time step",
       y = "Indicator") 

  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  loess_plots_1[[i]] <- plot_grid(title,
                                                     indicator_plots[[1]],
                                                     indicator_plots[[2]],
                                                     indicator_plots[[3]],
                                                     indicator_plots[[4]],
                                                     indicator_plots[[5]],
                                                     nrow = 2, align = "v")
rm(indicator_plots, indicator)

}
loess_plots_1[[1]]
loess_plots_1[[2]]
loess_plots_1[[3]]
loess_plots_1[[4]]

```

# Visualise the differenced indicator values (the difference between indicator at time t and indicator at time t - 1)

```{r plot differenced}

differenced_plots <- list()

for (i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
  
  # Get the indicator name
  
  indicator <- single_scenario[[j]]$indicator[1]


indicator_plots[[j]] <- ggplot(data = single_scenario[[j]], 
                               aes(x = annual_time_step,
                                   y = indicator_score_diff)) +
  geom_line() + 
  theme(axis.text = element_text(size = 2),
    axis.text.x = element_text(size = 1),
    axis.text.y = element_text(size = 1)) +
  labs(title = indicator,
       x = "Annual time step",
       y = "Differenced indicator score") 

  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  differenced_plots[[i]] <- plot_grid(title,
                                         indicator_plots[[1]],
                                         indicator_plots[[2]],
                                         indicator_plots[[3]],
                                         indicator_plots[[4]],
                                         indicator_plots[[5]],
                                         nrow = 2, align = "v")
rm(indicator_plots, indicator)

}

differenced_plots[[1]]
differenced_plots[[2]]
differenced_plots[[3]]
differenced_plots[[4]]

```

```{r breakpoints }
# https://www.marinedatascience.co/blog/2019/09/28/comparison-of-change-point-detection-methods/

# https://kevin-kotze.gitlab.io/tsm/ts-2-tut/
## Using the changepoint package

### NOTE: Changepoint doesn't find anything if we used differenced values
### but does if we just use normal values
# i <- i + 1
# data <- indicators_all_df %>% 
#         filter(scenario == "300_Harvesting_herbivores" &
#                indicator == indicators[i]) %>% 
#         mutate(lag_indicator_score_diff = lag(indicator_score_std, 1))
# 
# print(data$scenario[1])
# print(data$indicator[1])
# m_binseg <- cpt.mean(data$indicator_score_diff, penalty = "BIC", method = "BinSeg", Q = 5)
# plot(m_binseg, type = "l", xlab = "Index", cpt.width = 4, 
#      main = paste(data$scenario[1], data$indicator[1], sep = " "))
# 
# # Using the strucchange package - think it only identifies one break??
# ## Another tutorial https://datascienceplus.com/structural-changes-in-global-warming/
# 
# 
# head(data)
# 
# i <- i + 1
# data <- indicators_all_df %>% 
#         filter(scenario == "300_Harvesting_herbivores" &
#                indicator == indicators[i]) %>% 
#         mutate(lag_indicator_score_diff = lag(indicator_score_diff, 1))
# 
# data2 <- data[-1,]
# print(data2$indicator[1])
# qlr <- Fstats(lag_indicator_score_diff ~ indicator_score_diff, data = data2)
# breakpoints(qlr)
# summary(qlr)
# sctest(qlr, type = "supF")
# plot(qlr)

```
# Visualise the frequency distribution of the indicator values & abundance of harvested groups

```{r frequency distribution }

# Visualise the frequnecy distribution and density of indicators as in Bestelmeyer 2011

distribution_plots_1 <- list()

for (i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
  
  # Get the indicator name
  
  indicator <- single_scenario[[j]]$indicator[1]


indicator_plots[[j]] <- ggplot(data = single_scenario[[j]], 
                               aes(indicator_score_std)) +
  geom_histogram(aes(y = ..density..), colour="black", fill="white") +
  geom_density(alpha = 0.2, fill = "hotpink") + 
  theme(axis.text = element_text(size = 2),
    axis.text.x = element_text(size = 1),
    axis.text.y = element_text(size = 1)) +
  labs(title = indicator,
       x = "Indicator score",
       y = "Density") 

  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  distribution_plots_1[[i]] <- plot_grid(title,
                                         indicator_plots[[1]],
                                         indicator_plots[[2]],
                                         indicator_plots[[3]],
                                         indicator_plots[[4]],
                                         indicator_plots[[5]],
                                         nrow = 2, align = "v")
rm(indicator_plots, indicator)

}

distribution_plots_1[[1]]
distribution_plots_1[[2]]
distribution_plots_1[[3]]
distribution_plots_1[[4]]

```

# Split the same distributions by disturbance & non-disturbance time steps

```{r frequency distribution by disturbance }

# Visualise the frequnecy distribution and density of indicators as in Bestelmeyer 2011

distribution_plots_2 <- list()

for (i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
  
  # Get the indicator name
  
  indicator <- single_scenario[[j]]$indicator[1]
  
  
  indicator_plots[[j]] <- ggplot(data = single_scenario[[j]], 
                            aes(indicator_score_std)) +
  geom_histogram(aes(y = ..density.., group = disturbance_factor, 
                     fill = disturbance_factor), colour="black",
                   position = 'identity') +
  geom_density(aes(group = disturbance, 
                   fill = disturbance_factor),alpha = 0.2) + 
  scale_fill_manual(values=c("#69b3a2", "#404080")) +
  theme(axis.text = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    axis.text.y = element_text(size = 8),
    legend.title = element_blank(), 
    legend.text = element_text(size = 8),
    legend.position = "bottom") +
  labs(title = indicator,
       x = "Indicator score",
       y = "Density") 
  
  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  distribution_plots_2[[i]] <- plot_grid(title,
                                         indicator_plots[[1]],
                                         indicator_plots[[2]],
                                         indicator_plots[[3]],
                                         indicator_plots[[4]],
                                         indicator_plots[[5]],
                                         nrow = 2, align = "v")
rm(indicator_plots, indicator)

}

distribution_plots_2[[1]]
distribution_plots_2[[2]]
distribution_plots_2[[3]]
distribution_plots_2[[4]]

```
# Visualise red list status breakdown changes over time

```{r red list status plots}

scenario_extinctions <- list()
scenario_rl_status_plots <- list()

for (i in seq_along(scenario_redlist_data_sampled)) {
  
  # Add an ordered factor for plotting
  
  rl_status_fac <- factor(scenario_redlist_data_sampled[[i]]$rl_status,
      levels = c("LC", "NT", "VU", "EN", "CR", "EX"))
  
  scenario_redlist_data <- cbind(scenario_redlist_data_sampled[[i]],
  rl_status_fac = rl_status_fac)
  
  scenario_extinctions[[i]] <- scenario_redlist_data %>% 
          group_by(annual_time_step, rl_status_fac) %>% 
          filter(rl_status_fac != is.na(rl_status_fac)) %>% 
          summarise(red_list_status = n())
  
  # scenario_rl_status_plots[[i]] <- ggplot(scenario_extinctions[[i]], 
  #                                         aes(x = annual_time_step, 
  #                                             y = red_list_status, 
  #                                             fill = rl_status_fac)) +
  #   geom_bar(position = "stack", stat = "identity") +
  #   scale_fill_manual(values = c("#FDE725FF","#7AD151FF","#22A884FF","#2A788EFF",
  #                                "#414487FF","#440154FF")) +
  #   labs(title = scenarios_title[[i]])
  
 scenario_rl_status_plots[[i]] <- ggplot( scenario_extinctions[[i]],
                                          aes(x=annual_time_step, y=red_list_status, 
                                              fill=rl_status_fac)) +
    geom_area(  ) +
    scale_fill_manual(values = c("#FDE725FF","#7AD151FF","#22A884FF","#2A788EFF",
                                 "#414487FF","#440154FF")) +
    scale_color_manual(values = c("#FDE725FF","#7AD151FF","#22A884FF","#2A788EFF",
                                 "#414487FF","#440154FF")) +
   theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_rect(fill = "grey80"),
          legend.position = "bottom",
         legend.title=element_text(size=14), 
         legend.text=element_text(size=12),
          axis.title.x = element_text(size=14),
          axis.title.y = element_text(size=14),
          axis.text.x = element_text(size=12),
          axis.text.y = element_text(size=12),
          axis.ticks.x = element_blank(), 
          axis.ticks.y = element_blank()) +
   labs(title = scenarios_title[[i]],
        x = "Time (years)",
        y = "# species in Red List category") +
   guides(fill=guide_legend(title="Red List Status"))
   
  rm(scenario_redlist_data)
  
}

scenario_rl_status_plots[[1]]
scenario_rl_status_plots[[2]]
scenario_rl_status_plots[[3]]
scenario_rl_status_plots[[4]]

```

# Visualise the temporal variance 

```{r plot temporal variance, warning=FALSE, error = FALSE, message=FALSE}

variance_plots_3 <- list()

for (i in seq_along(scenario_indicators)) {
  
  # Get a list of indicator outputs for a single scenario
  single_scenario <- split(scenario_indicators[[i]], 
                           scenario_indicators[[i]]$indicator)
  
  scenario <- single_scenario[[1]]$scenario[1]
  
  indicator_plots <- list()
  
  for (j in seq_along(single_scenario)) {
  
  # Get the indicator name
  
  indicator <- single_scenario[[j]]$indicator[1]


indicator_plots[[j]] <- ggplot(data = single_scenario[[j]], 
                               aes(x = annual_time_step,
                                   y = variance)) +
  geom_line() + 
  theme(axis.text = element_text(size = 2),
    axis.text.x = element_text(size = 1),
    axis.text.y = element_text(size = 1)) +
  labs(title = indicator,
       x = "Annual time step",
       y = "Temporal variance") 

  }
  
  title <- ggdraw() + draw_label(scenarios_title[[i]])
  
  variance_plots_3[[i]] <- plot_grid(title,
                                         indicator_plots[[1]],
                                         indicator_plots[[2]],
                                         indicator_plots[[3]],
                                         indicator_plots[[4]],
                                         indicator_plots[[5]],
                                         nrow = 2, align = "v")
rm(indicator_plots, indicator)

}

variance_plots_3[[1]]
variance_plots_3[[2]]
variance_plots_3[[3]]
variance_plots_3[[4]]

```

```{r temporal autocorrelation }
# https://a-little-book-of-r-for-time-series.readthedocs.io/en/latest/src/timeseries.html 
# https://nwfsc-timeseries.github.io/atsa-labs/sec-tslab-correlation-within-and-among-time-series.html

# plotauto <- acf(test_df$indicator_score_std, lag.max = 300)
# plotauto
```

```{r trend modeling example}

# # Using the demo data
# head(ind_ex)
# head(press_ex)
# head(press_type_ex)
# # Scoring template:
# crit_scores_tmpl
# 
# m_trend <- model_trend(ind_tbl = ind_ex[ ,-1],
#   time = ind_ex$Year)
# 
# # Model diagnostics
# pd <- plot_diagnostics(model_list = m_trend$model)
# pd$all_plots[[1]] # first indicator
# # check for outliers in all models
# grid.arrange(grobs = pd$cooks_dist, ncol = 3) 
# # check normality in all models
# grid.arrange(grobs = pd$qq_plot, ncol = 3)
# # check homogeneity in all models
# grid.arrange(grobs = pd$resid_plot, ncol = 3)
# # check for autocorrelation in all models
# grid.arrange(grobs = pd$acf_plot, ncol = 3)
# # check for partial autocorrelation in all models
# grid.arrange(grobs = pd$pacf_plot, ncol = 3)
# 
# # Save diagnostic plots per indicator in a pdf
# ml <- marrangeGrob(grobs = pd$all_plots, ncol = 1, nrow = 1)
# ggsave("Trend_diagnostics.pdf", ml, height = 8, width = 12)
# 
# # Inspect trends
# pt <- plot_trend(m_trend)
# pt$TZA # shows trend of TZA indicator
# # show all together
# ml <- grid.arrange(grobs = pt, ncol = 3)
# ml
# # save as pdf
# ggsave("Trend_plots.pdf", ml, height = 12, width = 15)
# # show only significant trends
# grid.arrange(
#   grobs = pt[which(m_trend$p_val <= 0.05)],
#   ncol = 2
#     )

```

```{r prepare data for trend modelling }

# # Get one scenario
# single_scenario <- indicators_all_df %>% 
#                    filter(scenario == "100_Land_use") %>% 
#                    dplyr::select(annual_time_step, indicator, indicator_score)
# 
# single_scenario <- as.data.frame(single_scenario)
# 
# # Conver to wide format
# 
# ind_trend_inputs <- single_scenario %>% 
#                     pivot_wider(names_from = indicator,
#                                 values_from = indicator_score) %>% 
#                     arrange(annual_time_step)
# 
# pressure_inputs <- single_scenario %>% 
#                    filter(indicator == "total abundance harvested") %>% 
#                    pivot_wider(names_from = indicator,
#                                 values_from = indicator_score) %>% 
#                    arrange(annual_time_step)
                    

```

```{r model trends and plot diagnostics }

# m_trend <- model_trend(ind_tbl = ind_trend_inputs[ ,-1],
#   time = ind_trend_inputs$annual_time_step,
#   family = stats::Gamma())
# 
# # Model diagnostics
# pd <- plot_diagnostics(model_list = m_trend$model)
# pd$all_plots[[3]] # first indicator
# pd$all_plots[[4]]
# pd$all_plots[[5]]
# 
# # Save diagnostic plots per indicator in a pdf
# ml <- marrangeGrob(grobs = pd$all_plots, ncol = 1, nrow = 1)
# 
# # ggsave(file.path(analysis_plots_folder, 
# #                  "Trend_diagnostics.pdf"), 
# #                  ml, height = 8, width = 12)
# 
# ```
# 
# ```{r plot trends }
# 
# # Inspect trends
# pt <- plot_trend(m_trend)
# pt$TZA # shows trend of TZA indicator
# # show all together
# ml <- grid.arrange(grobs = pt, ncol = 3)
# ml
# # save as pdf
# ggsave("Trend_plots.pdf", ml, height = 12, width = 15)
# # show only significant trends
# grid.arrange(
#   grobs = pt[which(m_trend$p_val <= 0.05)],
#   ncol = 2
#     )


```

```{r prepare data for pressure - response modelling }

# dat_init <- ind_init(ind_tbl = ind_trend_inputs[ ,-1],
#   press_tbl = pressure_inputs[ ,-1], time = ind_trend_inputs$annual_time_step,
#     train = 0.9, random = FALSE)

```

```{r simple gams }

# m_gam <- model_gam(init_tbl = dat_init, k = 5,
#     family = stats::Gamma(), excl_outlier = NULL)
# 
# # Model diagnostics
# pd <- plot_diagnostics(model_list = m_gam$model)  # (might take a while)
# ml <- marrangeGrob(grobs = pd$all_plots, ncol = 1, nrow = 1)
# ggsave("GAM_diagnostics.pdf", ml, height = 8, width = 12)
# 
# # Any outlier?
# m_gam$pres_outlier %>% purrr::compact(.)
# # - get number of models with outliers detected
# purrr::map_lgl(m_gam$pres_outlier, ~!is.null(.)) %>% sum()
# # - which models and what observations?
# m_gam %>%
#     dplyr::select(id, ind, press, pres_outlier) %>%
#     dplyr::filter(!purrr::map_lgl(m_gam$pres_outlier, .f = is.null)) %>%
#     tidyr::unnest(pres_outlier)
# 
# # Exclude outlier in models (using the returned model output tibble as selector)
# m_gam <- model_gam(init_tbl = dat_init, excl_outlier = m_gam$pres_outlier)
# 
# # Any temporal autocorrelation (TAC)
# sum(m_gam$tac)
# 
# # - which models
# m_gam %>%
#     dplyr::select(id, ind, press, tac) %>%
#     dplyr::filter(tac)

```

```{r GAMMs for temporally autocorrelated }

# m_gamm <- model_gamm(init_tbl = dat_init,
#   filter = m_gam$tac,
#   family = Tweedie(p = 2)) # (apply GAMM only to rows where TAC detected)
# 
# # Again, any outlier?
# purrr::map_lgl(m_gamm$pres_outlier, ~!is.null(.)) %>% sum()
# 
# # Select best GAMM from different correlation structures
# # (based on AIC)
# best_gamm <- select_model(gam_tbl = m_gam, gamm_tbl = m_gamm)
# View(best_gamm)
# 
# # Still any temporal autocorrelation?
# sum(best_gamm$tac) 
# # - which models
# best_gamm %>%
#   dplyr::select(id, ind, press, tac, corrstruc) %>%
#   dplyr::filter(tac) %>%
#   print(n = 100)
# 
# # Inspect diagnostic plots of best GAMMs
# pd <- plot_diagnostics(model_list = best_gamm$model)
# ml <- marrangeGrob(grobs = pd$all_plots, ncol = 1, nrow = 1)
# ggsave(file.path(analysis_plots_folder, "bestGAMM_diagnostics.pdf"), 
#        ml, height = 8, width = 12)

 

```

```{r merge GAMS and GAMMS, eval= FALSE }
m_merged <- merge_models(m_gam[m_gam$tac == FALSE, ], best_gamm)

# View sign. models
filter(m_merged, p_val <= 0.05) %>%
  View()

sel <- find_id(
    mod_tbl = m_merged, 
    ind_name = indicators
)$id

m_merged$nrmse[sel] <- calc_nrmse(
    press = ind_init_ex$press_test[sel], 
    ind = ind_init_ex$ind_test[sel],
    model = m_merged$model[sel], 
    transformation = "log"
)

m_all <- m_merged

print("test")

```

```{r calculate derivatives, eval = FALSE}
# WARNING SLOW CODE
m_calc <- calc_deriv(init_tbl = dat_init, mod_tbl = m_merged,
    sign_level = 0.05)

```

```{r model selection, eval = FALSE }

it <- select_interaction(mod_tbl = m_calc)
# (creates combinations to test for)

m_all <- test_interaction(init_tbl = dat_init, mod_tbl = m_calc,
     interactions = it, sign_level = 0.05)

m_works <- m_all[-c(1,2), ]

# Inspect diagnostics of threshold models
pd_thresh <- m_works %>%
    # flatten structure of nested threshold GAMs 
    flatten() %>%
    # and remove empty lists (where no threshold GAMs were applied (=NULL) 
    # or no threshold GAMs were better than the simple GAMs (=NA)
    keep(~is.list(.x))  %>%
    plot_diagnostics()

ml <- marrangeGrob(grobs = pd_thresh$all_plots, ncol = 1, nrow = 1)
ggsave(file.path(analysis_plots_folder, "thresholdGAM_diagnostics.pdf"), 
       ml, height = 8, width = 10)

# Look at the development of the generalized cross-validation value 
# at different thresholds level: the plot should show that the GCVV
# of the final threshold should be clearly lower than of others 
# (you should see a single sharp trough, not at the edge)
grid.arrange(grobs = pd_thresh$gcvv_plot, ncol = 3)
# -> some models do NOT show this (e.g. #4,6,7): here we could set the
#  $interaction from TRUE to FALSE (for the scoring later) to ignore
# this potentially spurious interaction found:
m_all <- m_all %>% mutate(
    interaction = case_when(
    (ind == "Micro" & press == "Fsprat") |
        (ind == "Cod" & press == "Fher") | 
        (ind == "Cod" & press == "Fcod") ~ FALSE,
    TRUE ~ interaction))

```

```{r plot models,  eval = FALSE }


# Show final significant GAM/GAMM (threshold GAM) plots:
sel <- which(m_all$p_val <= 0.05)
pm <- plot_model(init_tbl = dat_init[sel, ], mod_tbl = m_all[sel, ])
# Save all sign. indicator plots
ml <- gridExtra::marrangeGrob(grobs = pm$all_plots, ncol = 1, nrow = 1)
ggplot2::ggsave(file.path(analysis_plots_folder, "Final_model_results.pdf"), 
                          ml, height = 10, width = 12)

```

```{r make my own GAMM,  eval = FALSE }

# * LPI ----
# *** Prep inputs ----

unique(indicators_all_df$indicator)
unique(indicators_all_df$scenario)
ind <- "LPI"
scen <- "100_Land_use"

response <- indicators_all_df %>% 
  filter(indicator == ind) %>% 
  filter(scenario == scen) %>% 
  rename(LPI = indicator_score)

predictor <- indicators_all_df %>% 
  filter(indicator == "total abundance harvested") %>% 
  filter(scenario == scen) %>% 
  rename(harvested = indicator_score) %>% 
  mutate(disturbance = ifelse(annual_time_step < 100|
                                annual_time_step > 200,
                              0, 1))

pr_gam_inputs <- response %>% 
  merge(predictor, by = "annual_time_step") %>% 
  mutate(LPI_scaled = scale(LPI),
         harvested_scaled = scale(harvested))

head(pr_gam_inputs)
summary(pr_gam_inputs)

# *** Fit trend models ----

hist(pr_gam_inputs$LPI_scaled, 60)
hist(pr_gam_inputs$harvested_scaled, 60)

m1 <- gam(LPI ~ s(annual_time_step) +
             s(harvested, k = 100), 
           data = pr_gam_inputs,
          family = Tweedie(p = 2))

gam.check(m1)
summary(m1)
plot(m1,pages=1)

m2 <- gam(LPI ~ s(annual_time_step, k = 100), 
          data = pr_gam_inputs,
          method = "GCV.Cp",
          select = TRUE,
          family = Tweedie(p = 2, link = "log"))

gam.check(m2)

m3 <- gamm(LPI ~ s(annual_time_step, k = 100), 
                 data = pr_gam_inputs,
                 correlation = corARMA(form = ~ annual_time_step, p = 1),
           family = Tweedie(p= 2, link = "log"))


# *** Model selection ----

## Using AIC
mod_sel_table <- as.data.frame(AIC(m1, m2, m3$lme))
mod_sel_table

# Define selected model

selected_mod <- m2

plot(selected_mod, residuals = TRUE, pch = 19, cex = 0.75)

```

```{r plot selected mods, eval = FALSE}

summary(pr_gam_inputs)

pdat <- data.frame(annual_time_step = seq(1, 295, 1))

head(pdat)

p <- predict(selected_mod, newdata = pdat, type = "response")
p
lines(p ~ annual_time_step, data = pdat, col = "pink")
# lines(p1 ~ annual_time_step, data = pdat, col = "red")
# lines(p2 ~ annual_time_step, data = pdat, col = "blue")
legend("topleft",
       legend = c("Uncorrelated Errors","AR(1) Errors"),
       bty = "n", col = c("red","blue"), lty = 1)

# *** Plot the derivatives and periods of change ----

m2.d <- Deriv(selected_mod$terms, n = 300)
plot(m2.d, sizer = TRUE, alpha = 0.01)

# Add periods of change to time series

plot(LPI ~ annual_time_step, data = pr_gam_inputs, 
     type = "p")
lines(p ~ annual_time_step, data = pdat)
CI <- confint(m2.d, alpha = 0.01)
S <- signifD(p, m2.d$annual_time_step$deriv, 
             CI$annual_time_step$upper, 
             CI$annual_time_step$lower,
             eval = 0)
lines(S$incr ~ annual_time_step, data = pdat, lwd = 3, col = "blue")
lines(S$decr ~ annual_time_step, data = pdat, lwd = 3, col = "red")
# Recreate with ggplot

deriv_plot <- ggplot() +
  geom_point(data = gam_inputs,
             aes(x = annual_time_step, y = indicator_score),
             alpha = 0.3) +
  geom_line(aes(x = gam_inputs$annual_time_step,
                y = p2)) +
  geom_line(aes(x = gam_inputs$annual_time_step, 
                y = S$incr), col = "blue", size = 2) +
  geom_line(aes(x = gam_inputs$annual_time_step, 
                y = S$decr), col = "red", size = 2) +
  labs(title = paste(gam_inputs$scenario[1],
                     gam_inputs$indicator[1], sep = " "))

deriv_plot

ggsave(file.path(analysis_plots_folder,
                 paste(gam_inputs$indicator[1],"_", gam_inputs$scenario[1], 
                       "derivative_plot.png", sep = "")),
       deriv_plot,  device = "png")

```
